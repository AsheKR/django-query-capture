{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"django-query-capture \u00a4 Overview \u00a4 Django Query Capture can check the query situation at a glance, notice slow queries, and notice where N+1 occurs. Some reasons you might want to use django-query-capture: It can be used to simply check queries in a specific block. It supports Django Middleware, Context Manager, and Decorator. When you use Context Manager, you can get real-time query data. You can see where the query occurs. Inefficient queries can be found in the test code. It is easy to customize by simply changing the table shape, changing the color, and selecting and setting the desired output. It supports customization that allows you to decorate the output freely from the beginning. Fully Documented It supports Type hint everywhere. Simple Usage \u00a4 Just add it to Middleware without any other settings, and it will be output whenever a query occurs. MIDDLEWARE = [ ... , \"django_query_capture.middleware.QueryCaptureMiddleware\" , ] Use in function-based views. or just function from django_query_capture import query_capture @query_capture () def my_view ( request ): pass Use in class-based views. from django.utils.decorators import method_decorator from django.views.generic import TemplateView from django_query_capture import query_capture @method_decorator ( query_capture , name = 'dispatch' ) class AboutView ( TemplateView ): pass Use it as a context. When used as Context, you can check the query in real time. from django_query_capture import query_capture from tests.news.models import Reporter @query_capture () def run_something (): with query_capture () as capture : Reporter . objects . create ( full_name = f \"target-1\" ) print ( len ( capture . captured_queries )) # console: 1 Reporter . objects . create ( full_name = f \"target-2\" ) print ( len ( capture . captured_queries )) # console: 2 Use in test Test code can capture inefficient queries through the AssertInefficientQuery Util. from django.test import TestCase from django_query_capture.test_utils import AssertInefficientQuery class AssertInefficientQueryTests ( TestCase ): def test_assert_inefficient_query ( self ): with AssertInefficientQuery ( self , num = 19 ): self . client . get ( '/api/reporter' ) # desire threshold count 19 but, /api/reporter duplicate query: 20, so raise error Installation \u00a4 pip install -U django-query-capture or install with Poetry poetry add django-query-capture \ud83d\udee1 License \u00a4 This project is licensed under the terms of the MIT license. See LICENSE for more details. Credits \u00a4 This project was generated with python-package-template","title":"Overview"},{"location":"#django-query-capture","text":"","title":"django-query-capture"},{"location":"#overview","text":"Django Query Capture can check the query situation at a glance, notice slow queries, and notice where N+1 occurs. Some reasons you might want to use django-query-capture: It can be used to simply check queries in a specific block. It supports Django Middleware, Context Manager, and Decorator. When you use Context Manager, you can get real-time query data. You can see where the query occurs. Inefficient queries can be found in the test code. It is easy to customize by simply changing the table shape, changing the color, and selecting and setting the desired output. It supports customization that allows you to decorate the output freely from the beginning. Fully Documented It supports Type hint everywhere.","title":"Overview"},{"location":"#simple-usage","text":"Just add it to Middleware without any other settings, and it will be output whenever a query occurs. MIDDLEWARE = [ ... , \"django_query_capture.middleware.QueryCaptureMiddleware\" , ] Use in function-based views. or just function from django_query_capture import query_capture @query_capture () def my_view ( request ): pass Use in class-based views. from django.utils.decorators import method_decorator from django.views.generic import TemplateView from django_query_capture import query_capture @method_decorator ( query_capture , name = 'dispatch' ) class AboutView ( TemplateView ): pass Use it as a context. When used as Context, you can check the query in real time. from django_query_capture import query_capture from tests.news.models import Reporter @query_capture () def run_something (): with query_capture () as capture : Reporter . objects . create ( full_name = f \"target-1\" ) print ( len ( capture . captured_queries )) # console: 1 Reporter . objects . create ( full_name = f \"target-2\" ) print ( len ( capture . captured_queries )) # console: 2 Use in test Test code can capture inefficient queries through the AssertInefficientQuery Util. from django.test import TestCase from django_query_capture.test_utils import AssertInefficientQuery class AssertInefficientQueryTests ( TestCase ): def test_assert_inefficient_query ( self ): with AssertInefficientQuery ( self , num = 19 ): self . client . get ( '/api/reporter' ) # desire threshold count 19 but, /api/reporter duplicate query: 20, so raise error","title":"Simple Usage"},{"location":"#installation","text":"pip install -U django-query-capture or install with Poetry poetry add django-query-capture","title":"Installation"},{"location":"#license","text":"This project is licensed under the terms of the MIT license. See LICENSE for more details.","title":"\ud83d\udee1 License"},{"location":"#credits","text":"This project was generated with python-package-template","title":"Credits"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at tech@ashe.kr. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at tech@ashe.kr. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"contributing/","text":"How to contribute \u00a4 Dependencies \u00a4 We use poetry to manage the dependencies . If you dont have poetry , you should install with make poetry-download . To install dependencies and prepare pre-commit hooks you would need to run install command: make install make pre-commit-install To activate your virtualenv run poetry shell . Codestyle \u00a4 After installation you may execute code formatting. make codestyle Checks \u00a4 Many checks are configured for this project. Command make check-codestyle will check black, isort and darglint. The make check-safety command will look at the security of your code. Comand make lint applies all checks. Before submitting \u00a4 Before submitting your code please do the following steps: Add any changes you want Add tests for the new changes Edit documentation if you have changed something significant Run make codestyle to format your changes. Run make lint to ensure that types, security and docstrings are okay. Other help \u00a4 You can contribute by spreading a word about this library. It would also be a huge contribution to write a short article on how you are using this project. You can also share your best practices with us.","title":"Contributing"},{"location":"contributing/#how-to-contribute","text":"","title":"How to contribute"},{"location":"contributing/#dependencies","text":"We use poetry to manage the dependencies . If you dont have poetry , you should install with make poetry-download . To install dependencies and prepare pre-commit hooks you would need to run install command: make install make pre-commit-install To activate your virtualenv run poetry shell .","title":"Dependencies"},{"location":"contributing/#codestyle","text":"After installation you may execute code formatting. make codestyle","title":"Codestyle"},{"location":"contributing/#checks","text":"Many checks are configured for this project. Command make check-codestyle will check black, isort and darglint. The make check-safety command will look at the security of your code. Comand make lint applies all checks.","title":"Checks"},{"location":"contributing/#before-submitting","text":"Before submitting your code please do the following steps: Add any changes you want Add tests for the new changes Edit documentation if you have changed something significant Run make codestyle to format your changes. Run make lint to ensure that types, security and docstrings are okay.","title":"Before submitting"},{"location":"contributing/#other-help","text":"You can contribute by spreading a word about this library. It would also be a huge contribution to write a short article on how you are using this project. You can also share your best practices with us.","title":"Other help"},{"location":"license/","text":"The MIT License (MIT) Copyright (c) 2022 AsheKR Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"api_guide/capture_query/","text":"API Reference \u00a4 It plays a role in capturing raw data and where the query occurred when the query first occurred. Just put data and do nothing. It can be used as Decorator with Context. In the entire flow, CapturedQuery receives the data and sends it to ClassifiedQuery. Classified data can be displayed in the Presenter. CapturedQuery \u00a4 A data class that adds the time and place of occurrence to the data that comes out when you capture Query in django. How to extract this data class will be described below . name description example sql SQL to which parameters are applied 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES (target-1)' raw_sql SQL to which parameters are not applied 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES (%s)' raw_params Parameters to be used for SQL ['target-1'] many a bool indicating whether the ultimately invoked call is execute() or executemany() (and whether params is expected to be a sequence of values, or a sequence of sequences of values). False duration Query execution time. 4.712500000003672e-05 file_name The file where the query was executed. 'test_native_query_capture.py' function_name A function in which the query was executed. 'test_capture_query_in_context_manager' line_no Row number where the query was executed. 16 context a dictionary with further data about the context of invocation. This includes the connection and cursor. CapturedQueryContext \u00a4 a dictionary with further data about the context of invocation. This includes the connection and cursor. For more information, please check the official document of Django . native_query_capture \u00a4 Both Context and Decorator are supported, but nothing happens when used as a Decorator. If you use it as Context, you can use the content of CapturedQuery . query_capture \u00a4 The highest level of module. It is a module responsible for both query capture, classification, and output. It has both low-level CapturedQuery data and ClassifiedQuery data. Real-time data can only be obtained when used as Context Manager. Example \u00a4 Decorator from django_query_capture import query_capture @query_capture () def my_view ( request ): pass Context Manager from django_query_capture import query_capture with query_capture () as capture : Reporter . objects . create ( full_name = f \"target-1\" ) print ( len ( capture . captured_queries )) # console: 1","title":"Capture Query"},{"location":"api_guide/capture_query/#api-reference","text":"It plays a role in capturing raw data and where the query occurred when the query first occurred. Just put data and do nothing. It can be used as Decorator with Context. In the entire flow, CapturedQuery receives the data and sends it to ClassifiedQuery. Classified data can be displayed in the Presenter.","title":"API Reference"},{"location":"api_guide/capture_query/#capturedquery","text":"A data class that adds the time and place of occurrence to the data that comes out when you capture Query in django. How to extract this data class will be described below . name description example sql SQL to which parameters are applied 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES (target-1)' raw_sql SQL to which parameters are not applied 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES (%s)' raw_params Parameters to be used for SQL ['target-1'] many a bool indicating whether the ultimately invoked call is execute() or executemany() (and whether params is expected to be a sequence of values, or a sequence of sequences of values). False duration Query execution time. 4.712500000003672e-05 file_name The file where the query was executed. 'test_native_query_capture.py' function_name A function in which the query was executed. 'test_capture_query_in_context_manager' line_no Row number where the query was executed. 16 context a dictionary with further data about the context of invocation. This includes the connection and cursor.","title":"CapturedQuery"},{"location":"api_guide/capture_query/#capturedquerycontext","text":"a dictionary with further data about the context of invocation. This includes the connection and cursor. For more information, please check the official document of Django .","title":"CapturedQueryContext"},{"location":"api_guide/capture_query/#native_query_capture","text":"Both Context and Decorator are supported, but nothing happens when used as a Decorator. If you use it as Context, you can use the content of CapturedQuery .","title":"native_query_capture"},{"location":"api_guide/capture_query/#query_capture","text":"The highest level of module. It is a module responsible for both query capture, classification, and output. It has both low-level CapturedQuery data and ClassifiedQuery data. Real-time data can only be obtained when used as Context Manager.","title":"query_capture"},{"location":"api_guide/capture_query/#example","text":"Decorator from django_query_capture import query_capture @query_capture () def my_view ( request ): pass Context Manager from django_query_capture import query_capture with query_capture () as capture : Reporter . objects . create ( full_name = f \"target-1\" ) print ( len ( capture . captured_queries )) # console: 1","title":"Example"},{"location":"api_guide/captured_query/","text":"API Reference \u00a4 It plays a role in capturing raw data and where the query occurred when the query first occurred. I just put data and do nothing. It can be used as Decorator with Context. In the entire flow, CapturedQuery receives the data and sends it to ClassifiedQuery. Classified data can be displayed in the Presenter. CapturedQuery \u00a4 CapturedQueryContext \u00a4 native_query_capture \u00a4","title":"API Reference"},{"location":"api_guide/captured_query/#api-reference","text":"It plays a role in capturing raw data and where the query occurred when the query first occurred. I just put data and do nothing. It can be used as Decorator with Context. In the entire flow, CapturedQuery receives the data and sends it to ClassifiedQuery. Classified data can be displayed in the Presenter.","title":"API Reference"},{"location":"api_guide/captured_query/#capturedquery","text":"","title":"CapturedQuery"},{"location":"api_guide/captured_query/#capturedquerycontext","text":"","title":"CapturedQueryContext"},{"location":"api_guide/captured_query/#native_query_capture","text":"","title":"native_query_capture"},{"location":"api_guide/classified_query/","text":"API Reference \u00a4 Process the data sent by CapturedQuery into the necessary information. Processed data will be viewed in the Presenter. ClassifiedQuery \u00a4 CapturedQueryClassifier \u00a4","title":"API Reference"},{"location":"api_guide/classified_query/#api-reference","text":"Process the data sent by CapturedQuery into the necessary information. Processed data will be viewed in the Presenter.","title":"API Reference"},{"location":"api_guide/classified_query/#classifiedquery","text":"","title":"ClassifiedQuery"},{"location":"api_guide/classified_query/#capturedqueryclassifier","text":"","title":"CapturedQueryClassifier"},{"location":"api_guide/presenter/","text":"API Reference \u00a4 It is responsible for displaying the data sent by ClassifiedQuery. By adding customized settings, processed data can be processed one more time to make the necessary output. BasePresenter \u00a4 You can inherit this class to create a new Presenter. All you have to do is override the print method. ClassifiedQuery It has only one attribute. Everything has a type hint. If you look at the example below how you implemented the class, you may have an idea. How to Customize Presenter \u00a4 Let's define a presenter that simply outputs the location of the query that occurs the most. Create a class that inherits the BasePresenter . \u00a4 from django_query_capture.presenter import BasePresenter class MostQueryLocationPresenter ( BasePresenter ): pass Refer to the property of ClassifiedQuery to get the most common similar. \u00a4 Refined properties refer to ClassifiedQuery , and individual properties such as sql and duration refer to ClassifiedQuery 's CapturedQuery . from django_query_capture.presenter import BasePresenter class MostSimilarQueryLocationPresenter ( BasePresenter ): def print ( self ): captured_query , counter = self . classified_query [ 'most_common_similar' ][ 0 ] # Get the counters of the most duplicated items. (Refer to typehint). if captured_query : print ( f '[ { captured_query [ \"function_name\" ] } , { captured_query [ \"file_name\" ] } : { captured_query [ \"line_no\" ] } ], duplicates { counter } times.' ) Import the Presenter defined in Settings. \u00a4 # settings.py QUERY_CAPTURE = { ... , \"PRESENTER\" : \"some.path.MostQuerySimilarLocationPresenter\" , } It's done! \u00a4 from django_query_capture import query_capture from news.models import Reporter @query_capture () def some_view (): for reporter in Reporter . objects . all (): for article in reporter . article_set . all (): # ... # Output # [some_function, some_path.py:50], similar 20 times. Example \u00a4 SimplePresenter RawLinePresenter PrettyPresenter OnlySlowQueryPresenter","title":"Presenter"},{"location":"api_guide/presenter/#api-reference","text":"It is responsible for displaying the data sent by ClassifiedQuery. By adding customized settings, processed data can be processed one more time to make the necessary output.","title":"API Reference"},{"location":"api_guide/presenter/#basepresenter","text":"You can inherit this class to create a new Presenter. All you have to do is override the print method. ClassifiedQuery It has only one attribute. Everything has a type hint. If you look at the example below how you implemented the class, you may have an idea.","title":"BasePresenter"},{"location":"api_guide/presenter/#how-to-customize-presenter","text":"Let's define a presenter that simply outputs the location of the query that occurs the most.","title":"How to Customize Presenter"},{"location":"api_guide/presenter/#create-a-class-that-inherits-the-basepresenter","text":"from django_query_capture.presenter import BasePresenter class MostQueryLocationPresenter ( BasePresenter ): pass","title":"Create a class that inherits the BasePresenter."},{"location":"api_guide/presenter/#refer-to-the-property-of-classifiedquery-to-get-the-most-common-similar","text":"Refined properties refer to ClassifiedQuery , and individual properties such as sql and duration refer to ClassifiedQuery 's CapturedQuery . from django_query_capture.presenter import BasePresenter class MostSimilarQueryLocationPresenter ( BasePresenter ): def print ( self ): captured_query , counter = self . classified_query [ 'most_common_similar' ][ 0 ] # Get the counters of the most duplicated items. (Refer to typehint). if captured_query : print ( f '[ { captured_query [ \"function_name\" ] } , { captured_query [ \"file_name\" ] } : { captured_query [ \"line_no\" ] } ], duplicates { counter } times.' )","title":"Refer to the property of ClassifiedQuery to get the most common similar."},{"location":"api_guide/presenter/#import-the-presenter-defined-in-settings","text":"# settings.py QUERY_CAPTURE = { ... , \"PRESENTER\" : \"some.path.MostQuerySimilarLocationPresenter\" , }","title":"Import the Presenter defined in Settings."},{"location":"api_guide/presenter/#its-done","text":"from django_query_capture import query_capture from news.models import Reporter @query_capture () def some_view (): for reporter in Reporter . objects . all (): for article in reporter . article_set . all (): # ... # Output # [some_function, some_path.py:50], similar 20 times.","title":"It's done!"},{"location":"api_guide/presenter/#example","text":"SimplePresenter RawLinePresenter PrettyPresenter OnlySlowQueryPresenter","title":"Example"},{"location":"api_guide/test_util/","text":"API Reference \u00a4 AssertInefficientQuery \u00a4 If the Duplicate, Similar, and Slow queries exceed the specified values, it is a test utility that fails. Usage \u00a4 name description available value test_case In Class-based TestCase, put self. All instances that inherited django.test.testcases.TestCase num If the duplication, Similar threshold, and query exceed num, the test fails. Optional[int] seconds If the query exceeds the specified time, the test fails. Optional[int] ignore_patterns This is a list of SQL Patterns to ignore.This is a list of SQL Patterns to ignore. List[str] Example \u00a4 assert Duplicate or Similar from django.test import TestCase from django_query_capture.test_utils import AssertInefficientQuery class AssertInefficientQueryTests ( TestCase ): def test_assert_inefficient_query ( self ): with AssertInefficientQuery ( self , num = 19 ): self . client . get ( '/api/reporter' ) # /api/reporter duplicate query: 20, so raise error assert Slow from django.test import TestCase from django_query_capture.test_utils import AssertInefficientQuery class AssertInefficientQueryTests ( TestCase ): def test_assert_inefficient_query ( self ): with AssertInefficientQuery ( self , seconds = 1 ): self . client . get ( '/api/reporter' ) # /api/reporter api took more than a second. so raise error","title":"Test Util"},{"location":"api_guide/test_util/#api-reference","text":"","title":"API Reference"},{"location":"api_guide/test_util/#assertinefficientquery","text":"If the Duplicate, Similar, and Slow queries exceed the specified values, it is a test utility that fails.","title":"AssertInefficientQuery"},{"location":"api_guide/test_util/#usage","text":"name description available value test_case In Class-based TestCase, put self. All instances that inherited django.test.testcases.TestCase num If the duplication, Similar threshold, and query exceed num, the test fails. Optional[int] seconds If the query exceeds the specified time, the test fails. Optional[int] ignore_patterns This is a list of SQL Patterns to ignore.This is a list of SQL Patterns to ignore. List[str]","title":"Usage"},{"location":"api_guide/test_util/#example","text":"assert Duplicate or Similar from django.test import TestCase from django_query_capture.test_utils import AssertInefficientQuery class AssertInefficientQueryTests ( TestCase ): def test_assert_inefficient_query ( self ): with AssertInefficientQuery ( self , num = 19 ): self . client . get ( '/api/reporter' ) # /api/reporter duplicate query: 20, so raise error assert Slow from django.test import TestCase from django_query_capture.test_utils import AssertInefficientQuery class AssertInefficientQueryTests ( TestCase ): def test_assert_inefficient_query ( self ): with AssertInefficientQuery ( self , seconds = 1 ): self . client . get ( '/api/reporter' ) # /api/reporter api took more than a second. so raise error","title":"Example"},{"location":"home/customize_presenter/","text":"How to Customize Presenter \u00a4 Let's define a presenter that simply outputs the location of the query that occurs the most. Create a class that inherits the BasePresenter . \u00a4 from django_query_capture.presenter import BasePresenter class MostQueryLocationPresenter ( BasePresenter ): pass Refer to the property of ClassifiedQuery to get the most common similar. \u00a4 Refined properties refer to ClassifiedQuery , and individual properties such as sql and duration refer to ClassifiedQuery 's CapturedQuery . from django_query_capture.presenter import BasePresenter class MostSimilarQueryLocationPresenter ( BasePresenter ): def print ( self ): captured_query , counter = self . classified_query [ 'most_common_similar' ][ 0 ] # Get the counters of the most duplicated items. (Refer to typehint). if captured_query : print ( f '[ { captured_query [ \"function_name\" ] } , { captured_query [ \"file_name\" ] } : { captured_query [ \"line_no\" ] } ], duplicates { counter } times.' ) Import the Presenter defined in Settings. \u00a4 # settings.py QUERY_CAPTURE = { ... , \"PRESENTER\" : \"some.path.MostQuerySimilarLocationPresenter\" , } It's done! \u00a4 from django_query_capture import query_capture from news.models import Reporter @query_capture () def some_view (): for reporter in Reporter . objects . all (): for article in reporter . article_set . all (): # ... # Output # [some_function, some_path.py:50], similar 20 times.","title":"How to Customize Presenter"},{"location":"home/customize_presenter/#how-to-customize-presenter","text":"Let's define a presenter that simply outputs the location of the query that occurs the most.","title":"How to Customize Presenter"},{"location":"home/customize_presenter/#create-a-class-that-inherits-the-basepresenter","text":"from django_query_capture.presenter import BasePresenter class MostQueryLocationPresenter ( BasePresenter ): pass","title":"Create a class that inherits the BasePresenter."},{"location":"home/customize_presenter/#refer-to-the-property-of-classifiedquery-to-get-the-most-common-similar","text":"Refined properties refer to ClassifiedQuery , and individual properties such as sql and duration refer to ClassifiedQuery 's CapturedQuery . from django_query_capture.presenter import BasePresenter class MostSimilarQueryLocationPresenter ( BasePresenter ): def print ( self ): captured_query , counter = self . classified_query [ 'most_common_similar' ][ 0 ] # Get the counters of the most duplicated items. (Refer to typehint). if captured_query : print ( f '[ { captured_query [ \"function_name\" ] } , { captured_query [ \"file_name\" ] } : { captured_query [ \"line_no\" ] } ], duplicates { counter } times.' )","title":"Refer to the property of ClassifiedQuery to get the most common similar."},{"location":"home/customize_presenter/#import-the-presenter-defined-in-settings","text":"# settings.py QUERY_CAPTURE = { ... , \"PRESENTER\" : \"some.path.MostQuerySimilarLocationPresenter\" , }","title":"Import the Presenter defined in Settings."},{"location":"home/customize_presenter/#its-done","text":"from django_query_capture import query_capture from news.models import Reporter @query_capture () def some_view (): for reporter in Reporter . objects . all (): for article in reporter . article_set . all (): # ... # Output # [some_function, some_path.py:50], similar 20 times.","title":"It's done!"},{"location":"home/overview/","text":"django-query-capture \u00a4 Overview \u00a4 Django Query Capture can check the query situation at a glance, notice slow queries, and notice where N+1 occurs. Some reasons you might want to use django-query-capture: It can be used to simply check queries in a specific block. It supports Django Middleware, Context Manager, and Decorator. When you use Context Manager, you can get real-time query data. You can see where the query occurs. Inefficient queries can be found in the test code. It is easy to customize by simply changing the table shape, changing the color, and selecting and setting the desired output. It supports customization that allows you to decorate the output freely from the beginning. Fully Documented It supports Type hint everywhere. Simple Usage \u00a4 Just add it to Middleware without any other settings, and it will be output whenever a query occurs. MIDDLEWARE = [ ... , \"django_query_capture.middleware.QueryCaptureMiddleware\" , ] Use in function-based views. or just function from django_query_capture import query_capture @query_capture () def my_view ( request ): pass Use in class-based views. from django.utils.decorators import method_decorator from django.views.generic import TemplateView from django_query_capture import query_capture @method_decorator ( query_capture , name = 'dispatch' ) class AboutView ( TemplateView ): pass Use it as a context. When used as Context, you can check the query in real time. from django_query_capture import query_capture from tests.news.models import Reporter @query_capture () def run_something (): with query_capture () as capture : Reporter . objects . create ( full_name = f \"target-1\" ) print ( len ( capture . captured_queries )) # console: 1 Reporter . objects . create ( full_name = f \"target-2\" ) print ( len ( capture . captured_queries )) # console: 2 Use in test Test code can capture inefficient queries through the AssertInefficientQuery Util. from django.test import TestCase from django_query_capture.test_utils import AssertInefficientQuery class AssertInefficientQueryTests ( TestCase ): def test_assert_inefficient_query ( self ): with AssertInefficientQuery ( self , num = 19 ): self . client . get ( '/api/reporter' ) # desire threshold count 19 but, /api/reporter duplicate query: 20, so raise error Installation \u00a4 pip install -U django-query-capture or install with Poetry poetry add django-query-capture \ud83d\udee1 License \u00a4 This project is licensed under the terms of the MIT license. See LICENSE for more details. Credits \u00a4 This project was generated with python-package-template","title":"Overview"},{"location":"home/overview/#django-query-capture","text":"","title":"django-query-capture"},{"location":"home/overview/#overview","text":"Django Query Capture can check the query situation at a glance, notice slow queries, and notice where N+1 occurs. Some reasons you might want to use django-query-capture: It can be used to simply check queries in a specific block. It supports Django Middleware, Context Manager, and Decorator. When you use Context Manager, you can get real-time query data. You can see where the query occurs. Inefficient queries can be found in the test code. It is easy to customize by simply changing the table shape, changing the color, and selecting and setting the desired output. It supports customization that allows you to decorate the output freely from the beginning. Fully Documented It supports Type hint everywhere.","title":"Overview"},{"location":"home/overview/#simple-usage","text":"Just add it to Middleware without any other settings, and it will be output whenever a query occurs. MIDDLEWARE = [ ... , \"django_query_capture.middleware.QueryCaptureMiddleware\" , ] Use in function-based views. or just function from django_query_capture import query_capture @query_capture () def my_view ( request ): pass Use in class-based views. from django.utils.decorators import method_decorator from django.views.generic import TemplateView from django_query_capture import query_capture @method_decorator ( query_capture , name = 'dispatch' ) class AboutView ( TemplateView ): pass Use it as a context. When used as Context, you can check the query in real time. from django_query_capture import query_capture from tests.news.models import Reporter @query_capture () def run_something (): with query_capture () as capture : Reporter . objects . create ( full_name = f \"target-1\" ) print ( len ( capture . captured_queries )) # console: 1 Reporter . objects . create ( full_name = f \"target-2\" ) print ( len ( capture . captured_queries )) # console: 2 Use in test Test code can capture inefficient queries through the AssertInefficientQuery Util. from django.test import TestCase from django_query_capture.test_utils import AssertInefficientQuery class AssertInefficientQueryTests ( TestCase ): def test_assert_inefficient_query ( self ): with AssertInefficientQuery ( self , num = 19 ): self . client . get ( '/api/reporter' ) # desire threshold count 19 but, /api/reporter duplicate query: 20, so raise error","title":"Simple Usage"},{"location":"home/overview/#installation","text":"pip install -U django-query-capture or install with Poetry poetry add django-query-capture","title":"Installation"},{"location":"home/overview/#license","text":"This project is licensed under the terms of the MIT license. See LICENSE for more details.","title":"\ud83d\udee1 License"},{"location":"home/overview/#credits","text":"This project was generated with python-package-template","title":"Credits"},{"location":"home/settings/","text":"In the setting, you can set the threshold and the form of the output. If you don't set anything up, the default value below will go in. QUERY_CAPTURE = { \"PRINT_THRESHOLDS\" : { # If you exceed the values below, it will be output to the console. \"SLOW_MIN_SECOND\" : 1 , # time thresholds \"DUPLICATE_MIN_COUNT\" : 10 , # duplicate query thresholds \"SIMILAR_MIN_COUNT\" : 10 , # similar query thresholds \"COLOR\" : \"yellow\" , # The color you want to show when you go over the thresholds. }, \"PRESENTER\" : \"django_query_capture.presenter.PrettyPresenter\" , # Output class, if you change this class, you can freely customize it. \"IGNORE_SQL_PATTERNS\" : [], # SQL Regex pattern list not to capture \"PRETTY\" : { \"TABLE_FORMAT\" : \"pretty\" , \"SQL_COLOR_FORMAT\" : \"friendly\" }, # Setting values that can be customized when using PrettyPresenter. } QUERY_CAPTURE \u00a4 name description available value PRINT_THRESHOLDS If you exceed the values below, it will be output to the console. The table below contains additional explanations. dict PRESENTER Output class, if you change this class, you can freely customize it. Class that inherited BasePresenter . Please refer to How to Customize Presenter IGNORE_SQL_PATTERNS SQL Regex pattern list not to capture list[str] PRETTY Setting values that can be customized when using PrettyPresenter . The table below contains additional explanations. dict PRINT_THRESHOLDS \u00a4 name description available value SLOW_MIN_SECOND time thresholds ( unit: second ) int DUPLICATE_MIN_COUNT duplicate query thresholds int SIMILAR_MIN_COUNT similar query thresholds int COLOR The color you want to show when you go over the thresholds. Please refer to here for a list of available colors. Similar vs Duplicate First, let's define it simply and understand it with one example. \"Similar\" has almost the same sql but only different parameters. \"Duplicate\" has exactly the same sql. This example is a \"Similar\" example. The preceding SQL is the same, but only the parameters are different. 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES ( %s )' % ( 'gil' ) 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES ( %s )' % ( 'young' ) 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES ( %s )' % ( 'ashe' ) This example is a \"Duplicate\" example. It's exactly the same. 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES ( %s )' % ( 'ashe' ) 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES ( %s )' % ( 'ashe' ) 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES ( %s )' % ( 'ashe' ) Custom color example It applies only to table colors. red green yellow blue magenta cyan white PRETTY \u00a4 name description available value TABLE_FORMAT You can specify the form of the table. Please refer to this place for the form that can be designated. SQL_COLOR_FORMAT You can adjust the color format when outputting SQL. Please refer to this place for the form that can be designated. Custom table format example All settings can be found here . plain simple github grid fancy_grid presto pretty psql pipe orgtbl Custom sql color format example All settings can be found here . zenburn material one-dark dracula","title":"Settings"},{"location":"home/settings/#query_capture","text":"name description available value PRINT_THRESHOLDS If you exceed the values below, it will be output to the console. The table below contains additional explanations. dict PRESENTER Output class, if you change this class, you can freely customize it. Class that inherited BasePresenter . Please refer to How to Customize Presenter IGNORE_SQL_PATTERNS SQL Regex pattern list not to capture list[str] PRETTY Setting values that can be customized when using PrettyPresenter . The table below contains additional explanations. dict","title":"QUERY_CAPTURE"},{"location":"home/settings/#print_thresholds","text":"name description available value SLOW_MIN_SECOND time thresholds ( unit: second ) int DUPLICATE_MIN_COUNT duplicate query thresholds int SIMILAR_MIN_COUNT similar query thresholds int COLOR The color you want to show when you go over the thresholds. Please refer to here for a list of available colors. Similar vs Duplicate First, let's define it simply and understand it with one example. \"Similar\" has almost the same sql but only different parameters. \"Duplicate\" has exactly the same sql. This example is a \"Similar\" example. The preceding SQL is the same, but only the parameters are different. 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES ( %s )' % ( 'gil' ) 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES ( %s )' % ( 'young' ) 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES ( %s )' % ( 'ashe' ) This example is a \"Duplicate\" example. It's exactly the same. 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES ( %s )' % ( 'ashe' ) 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES ( %s )' % ( 'ashe' ) 'INSERT INTO \"news_reporter\" (\"full_name\") VALUES ( %s )' % ( 'ashe' ) Custom color example It applies only to table colors. red green yellow blue magenta cyan white","title":"PRINT_THRESHOLDS"},{"location":"home/settings/#pretty","text":"name description available value TABLE_FORMAT You can specify the form of the table. Please refer to this place for the form that can be designated. SQL_COLOR_FORMAT You can adjust the color format when outputting SQL. Please refer to this place for the form that can be designated. Custom table format example All settings can be found here . plain simple github grid fancy_grid presto pretty psql pipe orgtbl Custom sql color format example All settings can be found here . zenburn material one-dark dracula","title":"PRETTY"},{"location":"reference/SUMMARY/","text":"capture.py classify.py decorators.py middleware.py presenter base.py only_slow_query.py pretty.py raw_line.py simple.py settings.py test_utils.py utils.py","title":"SUMMARY"},{"location":"reference/capture/","text":"This module is a code that expands and holds data by hooking whenever a query occurs in django. CapturedQuery ( dict ) \u00a4 A data class that adds the time and place of occurrence to the data that comes out when you capture Query in django. Source code in django_query_capture/capture.py class CapturedQuery ( typing . TypedDict ): \"\"\" A `data class` that adds the time and place of occurrence to the data that comes out when you capture Query in django. \"\"\" sql : str raw_sql : str raw_params : str many : bool duration : float file_name : str function_name : str line_no : int context : CapturedQueryContext CapturedQueryContext ( dict ) \u00a4 It is a data class that captures the data that appears as Context when you capture Query in django. Source code in django_query_capture/capture.py class CapturedQueryContext ( typing . TypedDict ): \"\"\" It is a `data class` that captures the data that appears as Context when you capture Query in django. \"\"\" connection : DatabaseWrapper cursor : CursorWrapper native_query_capture ( ContextDecorator ) \u00a4 This is the ContextDecorator that extends django's connection.execute_wrapper . measure the time of the query and guess where the query occurred. the main attribute is self.captured_queries , native_query_capture returns data from some captured_queries. Source code in django_query_capture/capture.py class native_query_capture ( ContextDecorator ): \"\"\" This is the `ContextDecorator` that extends django's `connection.execute_wrapper`.<br> measure the time of the query and guess where the query occurred.<br> the main attribute is [self.captured_queries][capture.CapturedQuery], [native_query_capture][capture.native_query_capture] returns data from some captured_queries. \"\"\" def __init__ ( self ): \"\"\" `self._exit_stack`: `ExitStack` was used to wrap `connection.execute_wrapper`.<br> `self.captured_queries`: Used to store captured queries and expanded data. \"\"\" self . _exit_stack = ExitStack () . __enter__ () self . captured_queries : typing . List [ CapturedQuery ] = [] def __enter__ ( self ) -> \"native_query_capture\" : \"\"\" Use exit_stack to perform `connection.execute_wrapper.__enter__`. Returns: Returns yourself with the property of [self.captured_queries][capture.CapturedQuery] so that you can check captured queries in real time. \"\"\" self . _exit_stack . enter_context ( connection . execute_wrapper ( self . _save_queries )) return self def __exit__ ( self , exc_type , exc_value , traceback ): \"\"\" Close exit_stack to call `connection.execute_wrapper.__exit___`. \"\"\" self . _exit_stack . close () def __len__ ( self ) -> int : \"\"\" Returns: Returns the length of [self.captured_queries][capture.CapturedQuery]. \"\"\" return len ( self . captured_queries ) def _save_queries ( self , execute , sql , params , many , context ): \"\"\" https://docs.djangoproject.com/en/3.2/topics/db/instrumentation/ It is a function used as a callback for execute_wrapper and receives a factor of `connection.execute_wrapper`.<br> measure the time of the query with the data provided by `connection.execute_wrapper`, track and store the query-generated CallStack. Args: execute: a callable, which should be invoked with the rest of the parameters in order to execute the query. sql: a str, the SQL query to be sent to the database. params: a list/tuple of parameter values for the SQL command, or a list/tuple of lists/tuples if the wrapped call is executemany(). many: a bool indicating whether the ultimately invoked call is execute() or executemany() (and whether params is expected to be a sequence of values, or a sequence of sequences of values). context: a dictionary with further data about the context of invocation. This includes the connection and cursor. Returns: Returns the result of the exit for the basic operation of `connection.execute_wrapper`. \"\"\" call_stack = [ stack for stack in inspect . stack () if \"site-packages\" not in stack . filename ] called_by = call_stack [ 1 ] file_name = called_by . filename . split ( \"/\" )[ - 1 ] function_name = called_by . function line_no = called_by . lineno start_timestamp = time . monotonic () result = execute ( sql , params , many , context ) duration = time . monotonic () - start_timestamp self . captured_queries . append ( { \"sql\" : sql % tuple ( params ) if params else sql , \"raw_sql\" : sql , \"raw_params\" : params , \"many\" : many , \"duration\" : duration , \"file_name\" : file_name , \"function_name\" : function_name , \"line_no\" : line_no , \"context\" : context , } ) return result __enter__ ( self ) special \u00a4 Use exit_stack to perform connection.execute_wrapper.__enter__ . Returns: Type Description native_query_capture Returns yourself with the property of self.captured_queries so that you can check captured queries in real time. Source code in django_query_capture/capture.py def __enter__ ( self ) -> \"native_query_capture\" : \"\"\" Use exit_stack to perform `connection.execute_wrapper.__enter__`. Returns: Returns yourself with the property of [self.captured_queries][capture.CapturedQuery] so that you can check captured queries in real time. \"\"\" self . _exit_stack . enter_context ( connection . execute_wrapper ( self . _save_queries )) return self __exit__ ( self , exc_type , exc_value , traceback ) special \u00a4 Close exit_stack to call connection.execute_wrapper.__exit___ . Source code in django_query_capture/capture.py def __exit__ ( self , exc_type , exc_value , traceback ): \"\"\" Close exit_stack to call `connection.execute_wrapper.__exit___`. \"\"\" self . _exit_stack . close () __init__ ( self ) special \u00a4 self._exit_stack : ExitStack was used to wrap connection.execute_wrapper . self.captured_queries : Used to store captured queries and expanded data. Source code in django_query_capture/capture.py def __init__ ( self ): \"\"\" `self._exit_stack`: `ExitStack` was used to wrap `connection.execute_wrapper`.<br> `self.captured_queries`: Used to store captured queries and expanded data. \"\"\" self . _exit_stack = ExitStack () . __enter__ () self . captured_queries : typing . List [ CapturedQuery ] = [] __len__ ( self ) special \u00a4 Returns: Type Description int Returns the length of self.captured_queries . Source code in django_query_capture/capture.py def __len__ ( self ) -> int : \"\"\" Returns: Returns the length of [self.captured_queries][capture.CapturedQuery]. \"\"\" return len ( self . captured_queries )","title":"capture.py"},{"location":"reference/capture/#capture.CapturedQuery","text":"A data class that adds the time and place of occurrence to the data that comes out when you capture Query in django. Source code in django_query_capture/capture.py class CapturedQuery ( typing . TypedDict ): \"\"\" A `data class` that adds the time and place of occurrence to the data that comes out when you capture Query in django. \"\"\" sql : str raw_sql : str raw_params : str many : bool duration : float file_name : str function_name : str line_no : int context : CapturedQueryContext","title":"CapturedQuery"},{"location":"reference/capture/#capture.CapturedQueryContext","text":"It is a data class that captures the data that appears as Context when you capture Query in django. Source code in django_query_capture/capture.py class CapturedQueryContext ( typing . TypedDict ): \"\"\" It is a `data class` that captures the data that appears as Context when you capture Query in django. \"\"\" connection : DatabaseWrapper cursor : CursorWrapper","title":"CapturedQueryContext"},{"location":"reference/capture/#capture.native_query_capture","text":"This is the ContextDecorator that extends django's connection.execute_wrapper . measure the time of the query and guess where the query occurred. the main attribute is self.captured_queries , native_query_capture returns data from some captured_queries. Source code in django_query_capture/capture.py class native_query_capture ( ContextDecorator ): \"\"\" This is the `ContextDecorator` that extends django's `connection.execute_wrapper`.<br> measure the time of the query and guess where the query occurred.<br> the main attribute is [self.captured_queries][capture.CapturedQuery], [native_query_capture][capture.native_query_capture] returns data from some captured_queries. \"\"\" def __init__ ( self ): \"\"\" `self._exit_stack`: `ExitStack` was used to wrap `connection.execute_wrapper`.<br> `self.captured_queries`: Used to store captured queries and expanded data. \"\"\" self . _exit_stack = ExitStack () . __enter__ () self . captured_queries : typing . List [ CapturedQuery ] = [] def __enter__ ( self ) -> \"native_query_capture\" : \"\"\" Use exit_stack to perform `connection.execute_wrapper.__enter__`. Returns: Returns yourself with the property of [self.captured_queries][capture.CapturedQuery] so that you can check captured queries in real time. \"\"\" self . _exit_stack . enter_context ( connection . execute_wrapper ( self . _save_queries )) return self def __exit__ ( self , exc_type , exc_value , traceback ): \"\"\" Close exit_stack to call `connection.execute_wrapper.__exit___`. \"\"\" self . _exit_stack . close () def __len__ ( self ) -> int : \"\"\" Returns: Returns the length of [self.captured_queries][capture.CapturedQuery]. \"\"\" return len ( self . captured_queries ) def _save_queries ( self , execute , sql , params , many , context ): \"\"\" https://docs.djangoproject.com/en/3.2/topics/db/instrumentation/ It is a function used as a callback for execute_wrapper and receives a factor of `connection.execute_wrapper`.<br> measure the time of the query with the data provided by `connection.execute_wrapper`, track and store the query-generated CallStack. Args: execute: a callable, which should be invoked with the rest of the parameters in order to execute the query. sql: a str, the SQL query to be sent to the database. params: a list/tuple of parameter values for the SQL command, or a list/tuple of lists/tuples if the wrapped call is executemany(). many: a bool indicating whether the ultimately invoked call is execute() or executemany() (and whether params is expected to be a sequence of values, or a sequence of sequences of values). context: a dictionary with further data about the context of invocation. This includes the connection and cursor. Returns: Returns the result of the exit for the basic operation of `connection.execute_wrapper`. \"\"\" call_stack = [ stack for stack in inspect . stack () if \"site-packages\" not in stack . filename ] called_by = call_stack [ 1 ] file_name = called_by . filename . split ( \"/\" )[ - 1 ] function_name = called_by . function line_no = called_by . lineno start_timestamp = time . monotonic () result = execute ( sql , params , many , context ) duration = time . monotonic () - start_timestamp self . captured_queries . append ( { \"sql\" : sql % tuple ( params ) if params else sql , \"raw_sql\" : sql , \"raw_params\" : params , \"many\" : many , \"duration\" : duration , \"file_name\" : file_name , \"function_name\" : function_name , \"line_no\" : line_no , \"context\" : context , } ) return result","title":"native_query_capture"},{"location":"reference/capture/#capture.native_query_capture.__enter__","text":"Use exit_stack to perform connection.execute_wrapper.__enter__ . Returns: Type Description native_query_capture Returns yourself with the property of self.captured_queries so that you can check captured queries in real time. Source code in django_query_capture/capture.py def __enter__ ( self ) -> \"native_query_capture\" : \"\"\" Use exit_stack to perform `connection.execute_wrapper.__enter__`. Returns: Returns yourself with the property of [self.captured_queries][capture.CapturedQuery] so that you can check captured queries in real time. \"\"\" self . _exit_stack . enter_context ( connection . execute_wrapper ( self . _save_queries )) return self","title":"__enter__()"},{"location":"reference/capture/#capture.native_query_capture.__exit__","text":"Close exit_stack to call connection.execute_wrapper.__exit___ . Source code in django_query_capture/capture.py def __exit__ ( self , exc_type , exc_value , traceback ): \"\"\" Close exit_stack to call `connection.execute_wrapper.__exit___`. \"\"\" self . _exit_stack . close ()","title":"__exit__()"},{"location":"reference/capture/#capture.native_query_capture.__init__","text":"self._exit_stack : ExitStack was used to wrap connection.execute_wrapper . self.captured_queries : Used to store captured queries and expanded data. Source code in django_query_capture/capture.py def __init__ ( self ): \"\"\" `self._exit_stack`: `ExitStack` was used to wrap `connection.execute_wrapper`.<br> `self.captured_queries`: Used to store captured queries and expanded data. \"\"\" self . _exit_stack = ExitStack () . __enter__ () self . captured_queries : typing . List [ CapturedQuery ] = []","title":"__init__()"},{"location":"reference/capture/#capture.native_query_capture.__len__","text":"Returns: Type Description int Returns the length of self.captured_queries . Source code in django_query_capture/capture.py def __len__ ( self ) -> int : \"\"\" Returns: Returns the length of [self.captured_queries][capture.CapturedQuery]. \"\"\" return len ( self . captured_queries )","title":"__len__()"},{"location":"reference/classify/","text":"If native_query_capture has received data, it serves to refine the data into the necessary data. HashableCapturedQuery In order to use collection.Counter , it was necessary to change the dict form to a hashable dict form. So, to classify Duplicate and Similar , we convert CapturedQuery dict into HashableDict form and use it as Counter's key. If there is a better way, feel free to leave it as an issue or PR. CapturedQueryClassifier \u00a4 This is the result of Classifier refining list of CapturedQuery . You can freely make output this data from the Presenter . Source code in django_query_capture/classify.py class CapturedQueryClassifier : \"\"\" This is the result of Classifier refining list of [CapturedQuery][capture.CapturedQuery]. You can freely make output this data from the `Presenter`. \"\"\" def __init__ ( self , captured_queries : typing . List [ CapturedQuery ], ignore_patterns : typing . Optional [ typing . List [ str ]] = None , ): \"\"\" Args: captured_queries: A list of [CapturedQuery][capture.CapturedQuery] collected by [native_query_capture][capture.native_query_capture]. ignore_patterns: REGEX string list that will not be used for classification among [CapturedQuery][capture.CapturedQuery]. \"\"\" self . ignore_patterns = ignore_patterns or get_config ()[ \"IGNORE_SQL_PATTERNS\" ] self . captured_queries = captured_queries self . filtered_captured_queries = [ captured_query for captured_query in captured_queries if self . is_allow_pattern ( captured_query [ \"sql\" ]) ] def __call__ ( self ) -> ClassifiedQuery : return { \"read\" : self . read_count , \"writes\" : self . writes_count , \"total\" : self . total_count , \"total_duration\" : self . total_duration , \"slow_captured_queries\" : self . slow_captured_queries , \"duplicates_counter\" : self . duplicates_counter , \"duplicates_counter_over_threshold\" : self . duplicates_counter_over_threshold , \"similar_counter\" : self . similar_counter , \"similar_counter_over_threshold\" : self . similar_counter_over_threshold , \"most_common_duplicate\" : self . most_common_duplicate , \"most_common_similar\" : self . most_common_similar , \"has_over_threshold\" : self . has_over_threshold , \"captured_queries\" : self . captured_queries , } def is_allow_pattern ( self , query : str ) -> bool : \"\"\" Args: query: It's simply a sql string. Returns: It is a list of [CapturedQuery][capture.CapturedQuery] that is not caught in ignore_patterns, that is, a classification target. \"\"\" return not list ( filter ( lambda pattern : re . compile ( pattern ) . search ( query ), self . ignore_patterns , ) ) @property def read_count ( self ) -> int : \"\"\" Returns: number of `SELECT` statement \"\"\" return sum ( 1 for capture_query in self . filtered_captured_queries if capture_query [ \"raw_sql\" ] . startswith ( \"SELECT\" ) ) @property def writes_count ( self ) -> int : \"\"\" Returns: number of not `SELECT` statement ( `INSERT`, `UPDATE`, `DELETE` ) \"\"\" return sum ( 1 for capture_query in self . filtered_captured_queries if not capture_query [ \"raw_sql\" ] . startswith ( \"SELECT\" ) ) @property def total_count ( self ) -> int : \"\"\" Returns: The number of all queries. \"\"\" return len ( self . filtered_captured_queries ) @property def total_duration ( self ) -> float : \"\"\" Returns: The total time the query was executed. \"\"\" return sum ( capture_query [ \"duration\" ] for capture_query in self . filtered_captured_queries ) @cached_property def slow_captured_queries ( self ) -> typing . List [ CapturedQuery ]: \"\"\" Returns: [CapturedQuery][capture.CapturedQuery] list with time exceeding [SLOW_MIN_SECOND](home/settings) \"\"\" results = [] slow_min_second = get_config ()[ \"PRINT_THRESHOLDS\" ][ \"SLOW_MIN_SECOND\" ] if slow_min_second is not None : for captured_query in self . filtered_captured_queries : if captured_query [ \"duration\" ] > slow_min_second : results . append ( captured_query ) return results @cached_property def duplicates_counter ( self ) -> typing . Counter [ CapturedQuery ]: \"\"\" Returns: `Counter` that counts the number of `Duplicate` in all queries except ignore_patterns. \"\"\" counter : typing . Counter [ CapturedQuery ] = Counter () for captured_query in self . filtered_captured_queries : counter [ DuplicateHashableCapturedQuery ( captured_query )] += 1 # type: ignore return counter @cached_property def duplicates_counter_over_threshold ( self ) -> typing . Counter [ CapturedQuery ]: \"\"\" Returns: CaptureQuery Counter that exceeds [DUPLICATE_MIN_COUNT](../home/settings.md) among [duplicates_counter][classify.CapturedQueryClassifier.duplicates_counter]. \"\"\" counter : typing . Counter [ CapturedQuery ] = Counter () duplicate_min_count : typing . Optional [ int ] = get_config ()[ \"PRINT_THRESHOLDS\" ][ \"DUPLICATE_MIN_COUNT\" ] if duplicate_min_count is not None : for captured_query , count in self . duplicates_counter . items (): if count > duplicate_min_count : counter [ captured_query ] = count return counter @cached_property def similar_counter ( self ) -> typing . Counter [ CapturedQuery ]: \"\"\" Returns: `Counter` that counts the number of `Similar` in all queries except ignore_patterns. \"\"\" counter : typing . Counter [ CapturedQuery ] = Counter () for captured_query in self . filtered_captured_queries : counter [ SimilarHashableCapturedQuery ( captured_query )] += 1 # type: ignore return counter @cached_property def similar_counter_over_threshold ( self ) -> typing . Counter [ CapturedQuery ]: \"\"\" Returns: [CaptureQuery][capture.CapturedQuery] `Counter` that exceeds [SIMILAR_MIN_COUNT](../home/settings.md) among [duplicates_counter][classify.CapturedQueryClassifier.duplicates_counter], it doesn't overlap with Duplicates. \"\"\" counter : typing . Counter [ CapturedQuery ] = Counter () similar_min_count : typing . Optional [ int ] = get_config ()[ \"PRINT_THRESHOLDS\" ][ \"SIMILAR_MIN_COUNT\" ] duplicate_min_count : typing . Optional [ int ] = get_config ()[ \"PRINT_THRESHOLDS\" ][ \"DUPLICATE_MIN_COUNT\" ] if similar_min_count is not None : for captured_query , count in self . similar_counter . items (): if duplicate_min_count is not None : if ( self . duplicates_counter [ DuplicateHashableCapturedQuery ( captured_query ) # type: ignore ] > duplicate_min_count ): continue if count > similar_min_count : counter [ captured_query ] = count return counter @property def most_common_duplicate ( self , ) -> typing . Union [ typing . Tuple [ CapturedQuery , int ], typing . Tuple [ None , None ]]: \"\"\" Returns: most frequent `Counter` among [duplicates_counter][classify.CapturedQueryClassifier.duplicates_counter]. \"\"\" try : return self . duplicates_counter . most_common ( 1 )[ 0 ] except IndexError : return None , None @property def most_common_similar ( self , ) -> typing . Union [ typing . Tuple [ CapturedQuery , int ], typing . Tuple [ None , None ]]: \"\"\" Returns: most frequent `Counter` among [duplicates_counter][classify.CapturedQueryClassifier.similar_counter]. \"\"\" try : return self . similar_counter . most_common ( 1 )[ 0 ] except IndexError : return None , None @property def has_over_threshold ( self ) -> bool : \"\"\" Returns: [SLOW_MIN_SECOND, DUPLICATE_MIN_COUNT, SIMILAR_MIN_COUNT](../home/settings.md)<br> If any of the three has exceeded the threshold, return `True`. \"\"\" if ( self . similar_counter_over_threshold or self . duplicates_counter_over_threshold or self . slow_captured_queries ): return True return False duplicates_counter : Counter [ django_query_capture . capture . CapturedQuery ] cached property writable \u00a4 Returns: Type Description Counter[django_query_capture.capture.CapturedQuery] Counter that counts the number of Duplicate in all queries except ignore_patterns. duplicates_counter_over_threshold : Counter [ django_query_capture . capture . CapturedQuery ] cached property writable \u00a4 Returns: Type Description Counter[django_query_capture.capture.CapturedQuery] CaptureQuery Counter that exceeds DUPLICATE_MIN_COUNT among duplicates_counter . has_over_threshold : bool property readonly \u00a4 Returns: Type Description bool SLOW_MIN_SECOND, DUPLICATE_MIN_COUNT, SIMILAR_MIN_COUNT If any of the three has exceeded the threshold, return True . most_common_duplicate : Union [ Tuple [ django_query_capture . capture . CapturedQuery , int ], Tuple [ NoneType ]] property readonly \u00a4 Returns: Type Description Union[Tuple[django_query_capture.capture.CapturedQuery, int], Tuple[NoneType]] most frequent Counter among duplicates_counter . most_common_similar : Union [ Tuple [ django_query_capture . capture . CapturedQuery , int ], Tuple [ NoneType ]] property readonly \u00a4 Returns: Type Description Union[Tuple[django_query_capture.capture.CapturedQuery, int], Tuple[NoneType]] most frequent Counter among duplicates_counter . read_count : int property readonly \u00a4 Returns: Type Description int number of SELECT statement similar_counter : Counter [ django_query_capture . capture . CapturedQuery ] cached property writable \u00a4 Returns: Type Description Counter[django_query_capture.capture.CapturedQuery] Counter that counts the number of Similar in all queries except ignore_patterns. similar_counter_over_threshold : Counter [ django_query_capture . capture . CapturedQuery ] cached property writable \u00a4 Returns: Type Description Counter[django_query_capture.capture.CapturedQuery] CaptureQuery Counter that exceeds SIMILAR_MIN_COUNT among duplicates_counter , it doesn't overlap with Duplicates. slow_captured_queries : List [ django_query_capture . capture . CapturedQuery ] cached property writable \u00a4 Returns: Type Description List[django_query_capture.capture.CapturedQuery] CapturedQuery list with time exceeding SLOW_MIN_SECOND total_count : int property readonly \u00a4 Returns: Type Description int The number of all queries. total_duration : float property readonly \u00a4 Returns: Type Description float The total time the query was executed. writes_count : int property readonly \u00a4 Returns: Type Description int number of not SELECT statement ( INSERT , UPDATE , DELETE ) __init__ ( self , captured_queries , ignore_patterns = None ) special \u00a4 Parameters: Name Type Description Default captured_queries List[django_query_capture.capture.CapturedQuery] A list of CapturedQuery collected by native_query_capture . required ignore_patterns Optional[List[str]] REGEX string list that will not be used for classification among CapturedQuery . None Source code in django_query_capture/classify.py def __init__ ( self , captured_queries : typing . List [ CapturedQuery ], ignore_patterns : typing . Optional [ typing . List [ str ]] = None , ): \"\"\" Args: captured_queries: A list of [CapturedQuery][capture.CapturedQuery] collected by [native_query_capture][capture.native_query_capture]. ignore_patterns: REGEX string list that will not be used for classification among [CapturedQuery][capture.CapturedQuery]. \"\"\" self . ignore_patterns = ignore_patterns or get_config ()[ \"IGNORE_SQL_PATTERNS\" ] self . captured_queries = captured_queries self . filtered_captured_queries = [ captured_query for captured_query in captured_queries if self . is_allow_pattern ( captured_query [ \"sql\" ]) ] is_allow_pattern ( self , query ) \u00a4 Parameters: Name Type Description Default query str It's simply a sql string. required Returns: Type Description bool It is a list of CapturedQuery that is not caught in ignore_patterns, that is, a classification target. Source code in django_query_capture/classify.py def is_allow_pattern ( self , query : str ) -> bool : \"\"\" Args: query: It's simply a sql string. Returns: It is a list of [CapturedQuery][capture.CapturedQuery] that is not caught in ignore_patterns, that is, a classification target. \"\"\" return not list ( filter ( lambda pattern : re . compile ( pattern ) . search ( query ), self . ignore_patterns , ) ) ClassifiedQuery ( dict ) \u00a4 This is the result of Classifier refining list of CapturedQuery . You can freely make output this data from the Presenter . Source code in django_query_capture/classify.py class ClassifiedQuery ( typing . TypedDict ): \"\"\" This is the result of Classifier refining list of [CapturedQuery][capture.CapturedQuery]. You can freely make output this data from the `Presenter`. \"\"\" read : int writes : int total : int total_duration : float slow_captured_queries : typing . List [ CapturedQuery ] duplicates_counter : typing . Counter [ CapturedQuery ] duplicates_counter_over_threshold : typing . Counter [ CapturedQuery ] similar_counter : typing . Counter [ CapturedQuery ] similar_counter_over_threshold : typing . Counter [ CapturedQuery ] most_common_duplicate : typing . Union [ typing . Tuple [ CapturedQuery , int ], typing . Tuple [ None , None ] ] most_common_similar : typing . Union [ typing . Tuple [ CapturedQuery , int ], typing . Tuple [ None , None ] ] has_over_threshold : bool captured_queries : typing . List [ CapturedQuery ] DuplicateHashableCapturedQuery ( dict , Generic ) \u00a4 Source code in django_query_capture/classify.py class DuplicateHashableCapturedQuery ( typing . Dict [ str , typing . Any ]): def __hash__ ( self ): return hash ( self [ \"sql\" ]) def __eq__ ( self , other ): return self [ \"sql\" ] == self [ \"sql\" ] __hash__ ( self ) special \u00a4 Return hash(self). Source code in django_query_capture/classify.py def __hash__ ( self ): return hash ( self [ \"sql\" ]) SimilarHashableCapturedQuery ( dict , Generic ) \u00a4 Source code in django_query_capture/classify.py class SimilarHashableCapturedQuery ( typing . Dict [ str , typing . Any ]): def __hash__ ( self ): return hash ( self [ \"raw_sql\" ]) def __eq__ ( self , other ): return self [ \"raw_sql\" ] == self [ \"raw_sql\" ] __hash__ ( self ) special \u00a4 Return hash(self). Source code in django_query_capture/classify.py def __hash__ ( self ): return hash ( self [ \"raw_sql\" ])","title":"classify.py"},{"location":"reference/classify/#classify.CapturedQueryClassifier","text":"This is the result of Classifier refining list of CapturedQuery . You can freely make output this data from the Presenter . Source code in django_query_capture/classify.py class CapturedQueryClassifier : \"\"\" This is the result of Classifier refining list of [CapturedQuery][capture.CapturedQuery]. You can freely make output this data from the `Presenter`. \"\"\" def __init__ ( self , captured_queries : typing . List [ CapturedQuery ], ignore_patterns : typing . Optional [ typing . List [ str ]] = None , ): \"\"\" Args: captured_queries: A list of [CapturedQuery][capture.CapturedQuery] collected by [native_query_capture][capture.native_query_capture]. ignore_patterns: REGEX string list that will not be used for classification among [CapturedQuery][capture.CapturedQuery]. \"\"\" self . ignore_patterns = ignore_patterns or get_config ()[ \"IGNORE_SQL_PATTERNS\" ] self . captured_queries = captured_queries self . filtered_captured_queries = [ captured_query for captured_query in captured_queries if self . is_allow_pattern ( captured_query [ \"sql\" ]) ] def __call__ ( self ) -> ClassifiedQuery : return { \"read\" : self . read_count , \"writes\" : self . writes_count , \"total\" : self . total_count , \"total_duration\" : self . total_duration , \"slow_captured_queries\" : self . slow_captured_queries , \"duplicates_counter\" : self . duplicates_counter , \"duplicates_counter_over_threshold\" : self . duplicates_counter_over_threshold , \"similar_counter\" : self . similar_counter , \"similar_counter_over_threshold\" : self . similar_counter_over_threshold , \"most_common_duplicate\" : self . most_common_duplicate , \"most_common_similar\" : self . most_common_similar , \"has_over_threshold\" : self . has_over_threshold , \"captured_queries\" : self . captured_queries , } def is_allow_pattern ( self , query : str ) -> bool : \"\"\" Args: query: It's simply a sql string. Returns: It is a list of [CapturedQuery][capture.CapturedQuery] that is not caught in ignore_patterns, that is, a classification target. \"\"\" return not list ( filter ( lambda pattern : re . compile ( pattern ) . search ( query ), self . ignore_patterns , ) ) @property def read_count ( self ) -> int : \"\"\" Returns: number of `SELECT` statement \"\"\" return sum ( 1 for capture_query in self . filtered_captured_queries if capture_query [ \"raw_sql\" ] . startswith ( \"SELECT\" ) ) @property def writes_count ( self ) -> int : \"\"\" Returns: number of not `SELECT` statement ( `INSERT`, `UPDATE`, `DELETE` ) \"\"\" return sum ( 1 for capture_query in self . filtered_captured_queries if not capture_query [ \"raw_sql\" ] . startswith ( \"SELECT\" ) ) @property def total_count ( self ) -> int : \"\"\" Returns: The number of all queries. \"\"\" return len ( self . filtered_captured_queries ) @property def total_duration ( self ) -> float : \"\"\" Returns: The total time the query was executed. \"\"\" return sum ( capture_query [ \"duration\" ] for capture_query in self . filtered_captured_queries ) @cached_property def slow_captured_queries ( self ) -> typing . List [ CapturedQuery ]: \"\"\" Returns: [CapturedQuery][capture.CapturedQuery] list with time exceeding [SLOW_MIN_SECOND](home/settings) \"\"\" results = [] slow_min_second = get_config ()[ \"PRINT_THRESHOLDS\" ][ \"SLOW_MIN_SECOND\" ] if slow_min_second is not None : for captured_query in self . filtered_captured_queries : if captured_query [ \"duration\" ] > slow_min_second : results . append ( captured_query ) return results @cached_property def duplicates_counter ( self ) -> typing . Counter [ CapturedQuery ]: \"\"\" Returns: `Counter` that counts the number of `Duplicate` in all queries except ignore_patterns. \"\"\" counter : typing . Counter [ CapturedQuery ] = Counter () for captured_query in self . filtered_captured_queries : counter [ DuplicateHashableCapturedQuery ( captured_query )] += 1 # type: ignore return counter @cached_property def duplicates_counter_over_threshold ( self ) -> typing . Counter [ CapturedQuery ]: \"\"\" Returns: CaptureQuery Counter that exceeds [DUPLICATE_MIN_COUNT](../home/settings.md) among [duplicates_counter][classify.CapturedQueryClassifier.duplicates_counter]. \"\"\" counter : typing . Counter [ CapturedQuery ] = Counter () duplicate_min_count : typing . Optional [ int ] = get_config ()[ \"PRINT_THRESHOLDS\" ][ \"DUPLICATE_MIN_COUNT\" ] if duplicate_min_count is not None : for captured_query , count in self . duplicates_counter . items (): if count > duplicate_min_count : counter [ captured_query ] = count return counter @cached_property def similar_counter ( self ) -> typing . Counter [ CapturedQuery ]: \"\"\" Returns: `Counter` that counts the number of `Similar` in all queries except ignore_patterns. \"\"\" counter : typing . Counter [ CapturedQuery ] = Counter () for captured_query in self . filtered_captured_queries : counter [ SimilarHashableCapturedQuery ( captured_query )] += 1 # type: ignore return counter @cached_property def similar_counter_over_threshold ( self ) -> typing . Counter [ CapturedQuery ]: \"\"\" Returns: [CaptureQuery][capture.CapturedQuery] `Counter` that exceeds [SIMILAR_MIN_COUNT](../home/settings.md) among [duplicates_counter][classify.CapturedQueryClassifier.duplicates_counter], it doesn't overlap with Duplicates. \"\"\" counter : typing . Counter [ CapturedQuery ] = Counter () similar_min_count : typing . Optional [ int ] = get_config ()[ \"PRINT_THRESHOLDS\" ][ \"SIMILAR_MIN_COUNT\" ] duplicate_min_count : typing . Optional [ int ] = get_config ()[ \"PRINT_THRESHOLDS\" ][ \"DUPLICATE_MIN_COUNT\" ] if similar_min_count is not None : for captured_query , count in self . similar_counter . items (): if duplicate_min_count is not None : if ( self . duplicates_counter [ DuplicateHashableCapturedQuery ( captured_query ) # type: ignore ] > duplicate_min_count ): continue if count > similar_min_count : counter [ captured_query ] = count return counter @property def most_common_duplicate ( self , ) -> typing . Union [ typing . Tuple [ CapturedQuery , int ], typing . Tuple [ None , None ]]: \"\"\" Returns: most frequent `Counter` among [duplicates_counter][classify.CapturedQueryClassifier.duplicates_counter]. \"\"\" try : return self . duplicates_counter . most_common ( 1 )[ 0 ] except IndexError : return None , None @property def most_common_similar ( self , ) -> typing . Union [ typing . Tuple [ CapturedQuery , int ], typing . Tuple [ None , None ]]: \"\"\" Returns: most frequent `Counter` among [duplicates_counter][classify.CapturedQueryClassifier.similar_counter]. \"\"\" try : return self . similar_counter . most_common ( 1 )[ 0 ] except IndexError : return None , None @property def has_over_threshold ( self ) -> bool : \"\"\" Returns: [SLOW_MIN_SECOND, DUPLICATE_MIN_COUNT, SIMILAR_MIN_COUNT](../home/settings.md)<br> If any of the three has exceeded the threshold, return `True`. \"\"\" if ( self . similar_counter_over_threshold or self . duplicates_counter_over_threshold or self . slow_captured_queries ): return True return False","title":"CapturedQueryClassifier"},{"location":"reference/classify/#classify.CapturedQueryClassifier.duplicates_counter","text":"Returns: Type Description Counter[django_query_capture.capture.CapturedQuery] Counter that counts the number of Duplicate in all queries except ignore_patterns.","title":"duplicates_counter"},{"location":"reference/classify/#classify.CapturedQueryClassifier.duplicates_counter_over_threshold","text":"Returns: Type Description Counter[django_query_capture.capture.CapturedQuery] CaptureQuery Counter that exceeds DUPLICATE_MIN_COUNT among duplicates_counter .","title":"duplicates_counter_over_threshold"},{"location":"reference/classify/#classify.CapturedQueryClassifier.has_over_threshold","text":"Returns: Type Description bool SLOW_MIN_SECOND, DUPLICATE_MIN_COUNT, SIMILAR_MIN_COUNT If any of the three has exceeded the threshold, return True .","title":"has_over_threshold"},{"location":"reference/classify/#classify.CapturedQueryClassifier.most_common_duplicate","text":"Returns: Type Description Union[Tuple[django_query_capture.capture.CapturedQuery, int], Tuple[NoneType]] most frequent Counter among duplicates_counter .","title":"most_common_duplicate"},{"location":"reference/classify/#classify.CapturedQueryClassifier.most_common_similar","text":"Returns: Type Description Union[Tuple[django_query_capture.capture.CapturedQuery, int], Tuple[NoneType]] most frequent Counter among duplicates_counter .","title":"most_common_similar"},{"location":"reference/classify/#classify.CapturedQueryClassifier.read_count","text":"Returns: Type Description int number of SELECT statement","title":"read_count"},{"location":"reference/classify/#classify.CapturedQueryClassifier.similar_counter","text":"Returns: Type Description Counter[django_query_capture.capture.CapturedQuery] Counter that counts the number of Similar in all queries except ignore_patterns.","title":"similar_counter"},{"location":"reference/classify/#classify.CapturedQueryClassifier.similar_counter_over_threshold","text":"Returns: Type Description Counter[django_query_capture.capture.CapturedQuery] CaptureQuery Counter that exceeds SIMILAR_MIN_COUNT among duplicates_counter , it doesn't overlap with Duplicates.","title":"similar_counter_over_threshold"},{"location":"reference/classify/#classify.CapturedQueryClassifier.slow_captured_queries","text":"Returns: Type Description List[django_query_capture.capture.CapturedQuery] CapturedQuery list with time exceeding SLOW_MIN_SECOND","title":"slow_captured_queries"},{"location":"reference/classify/#classify.CapturedQueryClassifier.total_count","text":"Returns: Type Description int The number of all queries.","title":"total_count"},{"location":"reference/classify/#classify.CapturedQueryClassifier.total_duration","text":"Returns: Type Description float The total time the query was executed.","title":"total_duration"},{"location":"reference/classify/#classify.CapturedQueryClassifier.writes_count","text":"Returns: Type Description int number of not SELECT statement ( INSERT , UPDATE , DELETE )","title":"writes_count"},{"location":"reference/classify/#classify.CapturedQueryClassifier.__init__","text":"Parameters: Name Type Description Default captured_queries List[django_query_capture.capture.CapturedQuery] A list of CapturedQuery collected by native_query_capture . required ignore_patterns Optional[List[str]] REGEX string list that will not be used for classification among CapturedQuery . None Source code in django_query_capture/classify.py def __init__ ( self , captured_queries : typing . List [ CapturedQuery ], ignore_patterns : typing . Optional [ typing . List [ str ]] = None , ): \"\"\" Args: captured_queries: A list of [CapturedQuery][capture.CapturedQuery] collected by [native_query_capture][capture.native_query_capture]. ignore_patterns: REGEX string list that will not be used for classification among [CapturedQuery][capture.CapturedQuery]. \"\"\" self . ignore_patterns = ignore_patterns or get_config ()[ \"IGNORE_SQL_PATTERNS\" ] self . captured_queries = captured_queries self . filtered_captured_queries = [ captured_query for captured_query in captured_queries if self . is_allow_pattern ( captured_query [ \"sql\" ]) ]","title":"__init__()"},{"location":"reference/classify/#classify.CapturedQueryClassifier.is_allow_pattern","text":"Parameters: Name Type Description Default query str It's simply a sql string. required Returns: Type Description bool It is a list of CapturedQuery that is not caught in ignore_patterns, that is, a classification target. Source code in django_query_capture/classify.py def is_allow_pattern ( self , query : str ) -> bool : \"\"\" Args: query: It's simply a sql string. Returns: It is a list of [CapturedQuery][capture.CapturedQuery] that is not caught in ignore_patterns, that is, a classification target. \"\"\" return not list ( filter ( lambda pattern : re . compile ( pattern ) . search ( query ), self . ignore_patterns , ) )","title":"is_allow_pattern()"},{"location":"reference/classify/#classify.ClassifiedQuery","text":"This is the result of Classifier refining list of CapturedQuery . You can freely make output this data from the Presenter . Source code in django_query_capture/classify.py class ClassifiedQuery ( typing . TypedDict ): \"\"\" This is the result of Classifier refining list of [CapturedQuery][capture.CapturedQuery]. You can freely make output this data from the `Presenter`. \"\"\" read : int writes : int total : int total_duration : float slow_captured_queries : typing . List [ CapturedQuery ] duplicates_counter : typing . Counter [ CapturedQuery ] duplicates_counter_over_threshold : typing . Counter [ CapturedQuery ] similar_counter : typing . Counter [ CapturedQuery ] similar_counter_over_threshold : typing . Counter [ CapturedQuery ] most_common_duplicate : typing . Union [ typing . Tuple [ CapturedQuery , int ], typing . Tuple [ None , None ] ] most_common_similar : typing . Union [ typing . Tuple [ CapturedQuery , int ], typing . Tuple [ None , None ] ] has_over_threshold : bool captured_queries : typing . List [ CapturedQuery ]","title":"ClassifiedQuery"},{"location":"reference/classify/#classify.DuplicateHashableCapturedQuery","text":"Source code in django_query_capture/classify.py class DuplicateHashableCapturedQuery ( typing . Dict [ str , typing . Any ]): def __hash__ ( self ): return hash ( self [ \"sql\" ]) def __eq__ ( self , other ): return self [ \"sql\" ] == self [ \"sql\" ]","title":"DuplicateHashableCapturedQuery"},{"location":"reference/classify/#classify.DuplicateHashableCapturedQuery.__hash__","text":"Return hash(self). Source code in django_query_capture/classify.py def __hash__ ( self ): return hash ( self [ \"sql\" ])","title":"__hash__()"},{"location":"reference/classify/#classify.SimilarHashableCapturedQuery","text":"Source code in django_query_capture/classify.py class SimilarHashableCapturedQuery ( typing . Dict [ str , typing . Any ]): def __hash__ ( self ): return hash ( self [ \"raw_sql\" ]) def __eq__ ( self , other ): return self [ \"raw_sql\" ] == self [ \"raw_sql\" ]","title":"SimilarHashableCapturedQuery"},{"location":"reference/classify/#classify.SimilarHashableCapturedQuery.__hash__","text":"Return hash(self). Source code in django_query_capture/classify.py def __hash__ ( self ): return hash ( self [ \"raw_sql\" ])","title":"__hash__()"},{"location":"reference/decorators/","text":"The highest level of module. It is a module responsible for both query capture, classification, and output. query_capture ( ContextDecorator ) \u00a4 Source code in django_query_capture/decorators.py class query_capture ( ContextDecorator ): def __init__ ( self , ignore_output : bool = False , ignore_patterns : typing . Optional [ typing . List [ str ]] = None , ): \"\"\" Args: ignore_output: Flag to prevent output. ignore_patterns: A list of patterns to ignore IGNORE_SQL_PATTERNS of settings. \"\"\" self . ignore_output = ignore_output self . ignore_patterns = ignore_patterns or get_config ()[ \"IGNORE_SQL_PATTERNS\" ] self . presenter_cls : typing . Type [ BasePresenter ] = import_string ( get_config ()[ \"PRESENTER\" ] ) def __enter__ ( self ) -> native_query_capture : r \"\"\" Call [native_query_capture.\\_\\_enter\\_\\_][capture.native_query_capture.__enter__] Returns: [native_query_capture][capture.native_query_capture] \"\"\" self . _exit_stack = ExitStack () . __enter__ () self . native_query_capture = native_query_capture () self . _exit_stack . enter_context ( self . native_query_capture ) return self . native_query_capture def __exit__ ( self , exc_type , exc_val , exc_tb ): r \"\"\" Call [native_query_capture.\\_\\_exit\\_\\_][capture.native_query_capture.__exit__].<br> Run the [CapturedQueryClassifier][classify.CapturedQueryClassifier] to extract meaningful data and transfer the data to the Presenter.<br> Presenter can be changed in settings, and if [BasePresenter][presenter.base.BasePresenter] is inherited and implemented, the desired output can be generated. \"\"\" self . classifier = CapturedQueryClassifier ( self . native_query_capture . captured_queries , ignore_patterns = self . ignore_patterns , )() if not self . ignore_output : self . presenter_cls ( self . classifier ) . print () self . _exit_stack . close () __enter__ ( self ) special \u00a4 Call native_query_capture.__enter__ Returns: Type Description native_query_capture native_query_capture Source code in django_query_capture/decorators.py def __enter__ ( self ) -> native_query_capture : r \"\"\" Call [native_query_capture.\\_\\_enter\\_\\_][capture.native_query_capture.__enter__] Returns: [native_query_capture][capture.native_query_capture] \"\"\" self . _exit_stack = ExitStack () . __enter__ () self . native_query_capture = native_query_capture () self . _exit_stack . enter_context ( self . native_query_capture ) return self . native_query_capture __exit__ ( self , exc_type , exc_val , exc_tb ) special \u00a4 Call native_query_capture.__exit__ . Run the CapturedQueryClassifier to extract meaningful data and transfer the data to the Presenter. Presenter can be changed in settings, and if BasePresenter is inherited and implemented, the desired output can be generated. Source code in django_query_capture/decorators.py def __exit__ ( self , exc_type , exc_val , exc_tb ): r \"\"\" Call [native_query_capture.\\_\\_exit\\_\\_][capture.native_query_capture.__exit__].<br> Run the [CapturedQueryClassifier][classify.CapturedQueryClassifier] to extract meaningful data and transfer the data to the Presenter.<br> Presenter can be changed in settings, and if [BasePresenter][presenter.base.BasePresenter] is inherited and implemented, the desired output can be generated. \"\"\" self . classifier = CapturedQueryClassifier ( self . native_query_capture . captured_queries , ignore_patterns = self . ignore_patterns , )() if not self . ignore_output : self . presenter_cls ( self . classifier ) . print () self . _exit_stack . close () __init__ ( self , ignore_output = False , ignore_patterns = None ) special \u00a4 Parameters: Name Type Description Default ignore_output bool Flag to prevent output. False ignore_patterns Optional[List[str]] A list of patterns to ignore IGNORE_SQL_PATTERNS of settings. None Source code in django_query_capture/decorators.py def __init__ ( self , ignore_output : bool = False , ignore_patterns : typing . Optional [ typing . List [ str ]] = None , ): \"\"\" Args: ignore_output: Flag to prevent output. ignore_patterns: A list of patterns to ignore IGNORE_SQL_PATTERNS of settings. \"\"\" self . ignore_output = ignore_output self . ignore_patterns = ignore_patterns or get_config ()[ \"IGNORE_SQL_PATTERNS\" ] self . presenter_cls : typing . Type [ BasePresenter ] = import_string ( get_config ()[ \"PRESENTER\" ] )","title":"decorators.py"},{"location":"reference/decorators/#decorators.query_capture","text":"Source code in django_query_capture/decorators.py class query_capture ( ContextDecorator ): def __init__ ( self , ignore_output : bool = False , ignore_patterns : typing . Optional [ typing . List [ str ]] = None , ): \"\"\" Args: ignore_output: Flag to prevent output. ignore_patterns: A list of patterns to ignore IGNORE_SQL_PATTERNS of settings. \"\"\" self . ignore_output = ignore_output self . ignore_patterns = ignore_patterns or get_config ()[ \"IGNORE_SQL_PATTERNS\" ] self . presenter_cls : typing . Type [ BasePresenter ] = import_string ( get_config ()[ \"PRESENTER\" ] ) def __enter__ ( self ) -> native_query_capture : r \"\"\" Call [native_query_capture.\\_\\_enter\\_\\_][capture.native_query_capture.__enter__] Returns: [native_query_capture][capture.native_query_capture] \"\"\" self . _exit_stack = ExitStack () . __enter__ () self . native_query_capture = native_query_capture () self . _exit_stack . enter_context ( self . native_query_capture ) return self . native_query_capture def __exit__ ( self , exc_type , exc_val , exc_tb ): r \"\"\" Call [native_query_capture.\\_\\_exit\\_\\_][capture.native_query_capture.__exit__].<br> Run the [CapturedQueryClassifier][classify.CapturedQueryClassifier] to extract meaningful data and transfer the data to the Presenter.<br> Presenter can be changed in settings, and if [BasePresenter][presenter.base.BasePresenter] is inherited and implemented, the desired output can be generated. \"\"\" self . classifier = CapturedQueryClassifier ( self . native_query_capture . captured_queries , ignore_patterns = self . ignore_patterns , )() if not self . ignore_output : self . presenter_cls ( self . classifier ) . print () self . _exit_stack . close ()","title":"query_capture"},{"location":"reference/decorators/#decorators.query_capture.__enter__","text":"Call native_query_capture.__enter__ Returns: Type Description native_query_capture native_query_capture Source code in django_query_capture/decorators.py def __enter__ ( self ) -> native_query_capture : r \"\"\" Call [native_query_capture.\\_\\_enter\\_\\_][capture.native_query_capture.__enter__] Returns: [native_query_capture][capture.native_query_capture] \"\"\" self . _exit_stack = ExitStack () . __enter__ () self . native_query_capture = native_query_capture () self . _exit_stack . enter_context ( self . native_query_capture ) return self . native_query_capture","title":"__enter__()"},{"location":"reference/decorators/#decorators.query_capture.__exit__","text":"Call native_query_capture.__exit__ . Run the CapturedQueryClassifier to extract meaningful data and transfer the data to the Presenter. Presenter can be changed in settings, and if BasePresenter is inherited and implemented, the desired output can be generated. Source code in django_query_capture/decorators.py def __exit__ ( self , exc_type , exc_val , exc_tb ): r \"\"\" Call [native_query_capture.\\_\\_exit\\_\\_][capture.native_query_capture.__exit__].<br> Run the [CapturedQueryClassifier][classify.CapturedQueryClassifier] to extract meaningful data and transfer the data to the Presenter.<br> Presenter can be changed in settings, and if [BasePresenter][presenter.base.BasePresenter] is inherited and implemented, the desired output can be generated. \"\"\" self . classifier = CapturedQueryClassifier ( self . native_query_capture . captured_queries , ignore_patterns = self . ignore_patterns , )() if not self . ignore_output : self . presenter_cls ( self . classifier ) . print () self . _exit_stack . close ()","title":"__exit__()"},{"location":"reference/decorators/#decorators.query_capture.__init__","text":"Parameters: Name Type Description Default ignore_output bool Flag to prevent output. False ignore_patterns Optional[List[str]] A list of patterns to ignore IGNORE_SQL_PATTERNS of settings. None Source code in django_query_capture/decorators.py def __init__ ( self , ignore_output : bool = False , ignore_patterns : typing . Optional [ typing . List [ str ]] = None , ): \"\"\" Args: ignore_output: Flag to prevent output. ignore_patterns: A list of patterns to ignore IGNORE_SQL_PATTERNS of settings. \"\"\" self . ignore_output = ignore_output self . ignore_patterns = ignore_patterns or get_config ()[ \"IGNORE_SQL_PATTERNS\" ] self . presenter_cls : typing . Type [ BasePresenter ] = import_string ( get_config ()[ \"PRESENTER\" ] )","title":"__init__()"},{"location":"reference/middleware/","text":"Middleware using query_capture available in django QueryCaptureMiddleware \u00a4 Capture all queries that occur when one request occurs and output them to the console. Source code in django_query_capture/middleware.py class QueryCaptureMiddleware : \"\"\" Capture all queries that occur when one request occurs and output them to the console. \"\"\" def __init__ ( self , get_response ): self . get_response = get_response @query_capture () def __call__ ( self , request ): return self . get_response ( request )","title":"middleware.py"},{"location":"reference/middleware/#middleware.QueryCaptureMiddleware","text":"Capture all queries that occur when one request occurs and output them to the console. Source code in django_query_capture/middleware.py class QueryCaptureMiddleware : \"\"\" Capture all queries that occur when one request occurs and output them to the console. \"\"\" def __init__ ( self , get_response ): self . get_response = get_response @query_capture () def __call__ ( self , request ): return self . get_response ( request )","title":"QueryCaptureMiddleware"},{"location":"reference/settings/","text":"This is the default setting of django_query_capture. You can adjust the threshold or change the shape of the output by referring to settings . get_config () \u00a4 Utilities that help you use the default settings if you don't use the user Returns: Type Description Dict[str, Any] Among the values of settings , the existing value is returned. Source code in django_query_capture/settings.py @lru_cache def get_config () -> typing . Dict [ str , typing . Any ]: \"\"\" Utilities that help you use the default settings if you don't use the user Returns: Among the values of [settings](../home/settings.md), the existing value is returned. \"\"\" USER_CONFIG = getattr ( settings , \"QUERY_CAPTURE\" , {}) CONFIG = CONFIG_DEFAULTS . copy () CONFIG . update ( USER_CONFIG ) return CONFIG update_toolbar_config ( * , setting , ** kwargs ) \u00a4 Refresh configuration when overriding settings. Source code in django_query_capture/settings.py @receiver ( setting_changed ) def update_toolbar_config ( * , setting , ** kwargs ): \"\"\" Refresh configuration when overriding settings. \"\"\" if setting == \"QUERY_CAPTURE\" : get_config . cache_clear ()","title":"settings.py"},{"location":"reference/settings/#settings.get_config","text":"Utilities that help you use the default settings if you don't use the user Returns: Type Description Dict[str, Any] Among the values of settings , the existing value is returned. Source code in django_query_capture/settings.py @lru_cache def get_config () -> typing . Dict [ str , typing . Any ]: \"\"\" Utilities that help you use the default settings if you don't use the user Returns: Among the values of [settings](../home/settings.md), the existing value is returned. \"\"\" USER_CONFIG = getattr ( settings , \"QUERY_CAPTURE\" , {}) CONFIG = CONFIG_DEFAULTS . copy () CONFIG . update ( USER_CONFIG ) return CONFIG","title":"get_config()"},{"location":"reference/settings/#settings.update_toolbar_config","text":"Refresh configuration when overriding settings. Source code in django_query_capture/settings.py @receiver ( setting_changed ) def update_toolbar_config ( * , setting , ** kwargs ): \"\"\" Refresh configuration when overriding settings. \"\"\" if setting == \"QUERY_CAPTURE\" : get_config . cache_clear ()","title":"update_toolbar_config()"},{"location":"reference/test_utils/","text":"Test utility to help you check Duplicate, Similar, and Slow queries in the test AssertInefficientQuery ( ContextDecorator ) \u00a4 Source code in django_query_capture/test_utils.py class AssertInefficientQuery ( ContextDecorator ): def __init__ ( self , test_case : TestCase , num : typing . Optional [ int ] = None , seconds : typing . Optional [ int ] = None , ignore_patterns : typing . Optional [ typing . List [ str ]] = None , ): \"\"\" Args: test_case: Class-based tests use `self`. num: `Duplicate`, `Similar` Threshold, The value of the setting is ignored. seconds: `Slow` Threshold, The value of the setting is ignored. ignore_patterns: A list of patterns to ignore IGNORE_SQL_PATTERNS of settings. \"\"\" self . test_case = test_case self . ignore_patterns = ignore_patterns or get_config ()[ \"IGNORE_SQL_PATTERNS\" ] self . num = num self . seconds = seconds def __enter__ ( self ): \"\"\" Run [query_capture.__enter__][decorators.query_capture] and `override_settings.__enter__` At this time, the `ignore_output=True` is set so that the output of [query_capture][decorators.query_capture] can be ignored. override_settings are used to ignore existing set values within the current context. \"\"\" self . _exit_stack = ExitStack () . __enter__ () self . query_capture = query_capture ( ignore_output = True ) config = get_config () . copy () config . update ( { \"PRINT_THRESHOLDS\" : { ** config [ \"PRINT_THRESHOLDS\" ], \"SLOW_MIN_SECOND\" : self . seconds , \"DUPLICATE_MIN_COUNT\" : self . num , \"SIMILAR_MIN_COUNT\" : self . num , } } ) self . _exit_stack . enter_context ( override_settings ( QUERY_CAPTURE = config )) self . _exit_stack . enter_context ( self . query_capture ) return self . query_capture def __exit__ ( self , exc_type , exc_val , exc_tb ): \"\"\" End the context of [query_capture][decorators.query_capture] and override_settings. And if there is an item above the threshold, the test fails and the failed content is printed. \"\"\" self . _exit_stack . close () classifier = self . query_capture . classifier result = \"\" if classifier [ \"duplicates_counter_over_threshold\" ]: for captured_query , count in classifier [ \"duplicates_counter_over_threshold\" ] . items (): result += f ' \\n { get_stack_prefix ( captured_query ) } Duplicates { count } times: { truncate_string ( captured_query [ \"sql\" ], 25 ) } ' if classifier [ \"similar_counter_over_threshold\" ]: for captured_query , count in classifier [ \"similar_counter_over_threshold\" ] . items (): result += f ' \\n { get_stack_prefix ( captured_query ) } Similar { count } times: { truncate_string ( captured_query [ \"raw_sql\" ], 25 ) } ' if classifier [ \"slow_captured_queries\" ]: for captured_query in classifier [ \"slow_captured_queries\" ]: result += f ' \\n { get_stack_prefix ( captured_query ) } Slow { captured_query [ \"duration\" ] : .2f } seconds: { truncate_string ( captured_query [ \"raw_sql\" ], 25 ) } ' self . test_case . assertFalse ( bool ( result ), result ) __enter__ ( self ) special \u00a4 Run query_capture. enter and override_settings.__enter__ At this time, the ignore_output=True is set so that the output of query_capture can be ignored. override_settings are used to ignore existing set values within the current context. Source code in django_query_capture/test_utils.py def __enter__ ( self ): \"\"\" Run [query_capture.__enter__][decorators.query_capture] and `override_settings.__enter__` At this time, the `ignore_output=True` is set so that the output of [query_capture][decorators.query_capture] can be ignored. override_settings are used to ignore existing set values within the current context. \"\"\" self . _exit_stack = ExitStack () . __enter__ () self . query_capture = query_capture ( ignore_output = True ) config = get_config () . copy () config . update ( { \"PRINT_THRESHOLDS\" : { ** config [ \"PRINT_THRESHOLDS\" ], \"SLOW_MIN_SECOND\" : self . seconds , \"DUPLICATE_MIN_COUNT\" : self . num , \"SIMILAR_MIN_COUNT\" : self . num , } } ) self . _exit_stack . enter_context ( override_settings ( QUERY_CAPTURE = config )) self . _exit_stack . enter_context ( self . query_capture ) return self . query_capture __exit__ ( self , exc_type , exc_val , exc_tb ) special \u00a4 End the context of query_capture and override_settings. And if there is an item above the threshold, the test fails and the failed content is printed. Source code in django_query_capture/test_utils.py def __exit__ ( self , exc_type , exc_val , exc_tb ): \"\"\" End the context of [query_capture][decorators.query_capture] and override_settings. And if there is an item above the threshold, the test fails and the failed content is printed. \"\"\" self . _exit_stack . close () classifier = self . query_capture . classifier result = \"\" if classifier [ \"duplicates_counter_over_threshold\" ]: for captured_query , count in classifier [ \"duplicates_counter_over_threshold\" ] . items (): result += f ' \\n { get_stack_prefix ( captured_query ) } Duplicates { count } times: { truncate_string ( captured_query [ \"sql\" ], 25 ) } ' if classifier [ \"similar_counter_over_threshold\" ]: for captured_query , count in classifier [ \"similar_counter_over_threshold\" ] . items (): result += f ' \\n { get_stack_prefix ( captured_query ) } Similar { count } times: { truncate_string ( captured_query [ \"raw_sql\" ], 25 ) } ' if classifier [ \"slow_captured_queries\" ]: for captured_query in classifier [ \"slow_captured_queries\" ]: result += f ' \\n { get_stack_prefix ( captured_query ) } Slow { captured_query [ \"duration\" ] : .2f } seconds: { truncate_string ( captured_query [ \"raw_sql\" ], 25 ) } ' self . test_case . assertFalse ( bool ( result ), result ) __init__ ( self , test_case , num = None , seconds = None , ignore_patterns = None ) special \u00a4 Parameters: Name Type Description Default test_case TestCase Class-based tests use self . required num Optional[int] Duplicate , Similar Threshold, The value of the setting is ignored. None seconds Optional[int] Slow Threshold, The value of the setting is ignored. None ignore_patterns Optional[List[str]] A list of patterns to ignore IGNORE_SQL_PATTERNS of settings. None Source code in django_query_capture/test_utils.py def __init__ ( self , test_case : TestCase , num : typing . Optional [ int ] = None , seconds : typing . Optional [ int ] = None , ignore_patterns : typing . Optional [ typing . List [ str ]] = None , ): \"\"\" Args: test_case: Class-based tests use `self`. num: `Duplicate`, `Similar` Threshold, The value of the setting is ignored. seconds: `Slow` Threshold, The value of the setting is ignored. ignore_patterns: A list of patterns to ignore IGNORE_SQL_PATTERNS of settings. \"\"\" self . test_case = test_case self . ignore_patterns = ignore_patterns or get_config ()[ \"IGNORE_SQL_PATTERNS\" ] self . num = num self . seconds = seconds","title":"test_utils.py"},{"location":"reference/test_utils/#test_utils.AssertInefficientQuery","text":"Source code in django_query_capture/test_utils.py class AssertInefficientQuery ( ContextDecorator ): def __init__ ( self , test_case : TestCase , num : typing . Optional [ int ] = None , seconds : typing . Optional [ int ] = None , ignore_patterns : typing . Optional [ typing . List [ str ]] = None , ): \"\"\" Args: test_case: Class-based tests use `self`. num: `Duplicate`, `Similar` Threshold, The value of the setting is ignored. seconds: `Slow` Threshold, The value of the setting is ignored. ignore_patterns: A list of patterns to ignore IGNORE_SQL_PATTERNS of settings. \"\"\" self . test_case = test_case self . ignore_patterns = ignore_patterns or get_config ()[ \"IGNORE_SQL_PATTERNS\" ] self . num = num self . seconds = seconds def __enter__ ( self ): \"\"\" Run [query_capture.__enter__][decorators.query_capture] and `override_settings.__enter__` At this time, the `ignore_output=True` is set so that the output of [query_capture][decorators.query_capture] can be ignored. override_settings are used to ignore existing set values within the current context. \"\"\" self . _exit_stack = ExitStack () . __enter__ () self . query_capture = query_capture ( ignore_output = True ) config = get_config () . copy () config . update ( { \"PRINT_THRESHOLDS\" : { ** config [ \"PRINT_THRESHOLDS\" ], \"SLOW_MIN_SECOND\" : self . seconds , \"DUPLICATE_MIN_COUNT\" : self . num , \"SIMILAR_MIN_COUNT\" : self . num , } } ) self . _exit_stack . enter_context ( override_settings ( QUERY_CAPTURE = config )) self . _exit_stack . enter_context ( self . query_capture ) return self . query_capture def __exit__ ( self , exc_type , exc_val , exc_tb ): \"\"\" End the context of [query_capture][decorators.query_capture] and override_settings. And if there is an item above the threshold, the test fails and the failed content is printed. \"\"\" self . _exit_stack . close () classifier = self . query_capture . classifier result = \"\" if classifier [ \"duplicates_counter_over_threshold\" ]: for captured_query , count in classifier [ \"duplicates_counter_over_threshold\" ] . items (): result += f ' \\n { get_stack_prefix ( captured_query ) } Duplicates { count } times: { truncate_string ( captured_query [ \"sql\" ], 25 ) } ' if classifier [ \"similar_counter_over_threshold\" ]: for captured_query , count in classifier [ \"similar_counter_over_threshold\" ] . items (): result += f ' \\n { get_stack_prefix ( captured_query ) } Similar { count } times: { truncate_string ( captured_query [ \"raw_sql\" ], 25 ) } ' if classifier [ \"slow_captured_queries\" ]: for captured_query in classifier [ \"slow_captured_queries\" ]: result += f ' \\n { get_stack_prefix ( captured_query ) } Slow { captured_query [ \"duration\" ] : .2f } seconds: { truncate_string ( captured_query [ \"raw_sql\" ], 25 ) } ' self . test_case . assertFalse ( bool ( result ), result )","title":"AssertInefficientQuery"},{"location":"reference/test_utils/#test_utils.AssertInefficientQuery.__enter__","text":"Run query_capture. enter and override_settings.__enter__ At this time, the ignore_output=True is set so that the output of query_capture can be ignored. override_settings are used to ignore existing set values within the current context. Source code in django_query_capture/test_utils.py def __enter__ ( self ): \"\"\" Run [query_capture.__enter__][decorators.query_capture] and `override_settings.__enter__` At this time, the `ignore_output=True` is set so that the output of [query_capture][decorators.query_capture] can be ignored. override_settings are used to ignore existing set values within the current context. \"\"\" self . _exit_stack = ExitStack () . __enter__ () self . query_capture = query_capture ( ignore_output = True ) config = get_config () . copy () config . update ( { \"PRINT_THRESHOLDS\" : { ** config [ \"PRINT_THRESHOLDS\" ], \"SLOW_MIN_SECOND\" : self . seconds , \"DUPLICATE_MIN_COUNT\" : self . num , \"SIMILAR_MIN_COUNT\" : self . num , } } ) self . _exit_stack . enter_context ( override_settings ( QUERY_CAPTURE = config )) self . _exit_stack . enter_context ( self . query_capture ) return self . query_capture","title":"__enter__()"},{"location":"reference/test_utils/#test_utils.AssertInefficientQuery.__exit__","text":"End the context of query_capture and override_settings. And if there is an item above the threshold, the test fails and the failed content is printed. Source code in django_query_capture/test_utils.py def __exit__ ( self , exc_type , exc_val , exc_tb ): \"\"\" End the context of [query_capture][decorators.query_capture] and override_settings. And if there is an item above the threshold, the test fails and the failed content is printed. \"\"\" self . _exit_stack . close () classifier = self . query_capture . classifier result = \"\" if classifier [ \"duplicates_counter_over_threshold\" ]: for captured_query , count in classifier [ \"duplicates_counter_over_threshold\" ] . items (): result += f ' \\n { get_stack_prefix ( captured_query ) } Duplicates { count } times: { truncate_string ( captured_query [ \"sql\" ], 25 ) } ' if classifier [ \"similar_counter_over_threshold\" ]: for captured_query , count in classifier [ \"similar_counter_over_threshold\" ] . items (): result += f ' \\n { get_stack_prefix ( captured_query ) } Similar { count } times: { truncate_string ( captured_query [ \"raw_sql\" ], 25 ) } ' if classifier [ \"slow_captured_queries\" ]: for captured_query in classifier [ \"slow_captured_queries\" ]: result += f ' \\n { get_stack_prefix ( captured_query ) } Slow { captured_query [ \"duration\" ] : .2f } seconds: { truncate_string ( captured_query [ \"raw_sql\" ], 25 ) } ' self . test_case . assertFalse ( bool ( result ), result )","title":"__exit__()"},{"location":"reference/test_utils/#test_utils.AssertInefficientQuery.__init__","text":"Parameters: Name Type Description Default test_case TestCase Class-based tests use self . required num Optional[int] Duplicate , Similar Threshold, The value of the setting is ignored. None seconds Optional[int] Slow Threshold, The value of the setting is ignored. None ignore_patterns Optional[List[str]] A list of patterns to ignore IGNORE_SQL_PATTERNS of settings. None Source code in django_query_capture/test_utils.py def __init__ ( self , test_case : TestCase , num : typing . Optional [ int ] = None , seconds : typing . Optional [ int ] = None , ignore_patterns : typing . Optional [ typing . List [ str ]] = None , ): \"\"\" Args: test_case: Class-based tests use `self`. num: `Duplicate`, `Similar` Threshold, The value of the setting is ignored. seconds: `Slow` Threshold, The value of the setting is ignored. ignore_patterns: A list of patterns to ignore IGNORE_SQL_PATTERNS of settings. \"\"\" self . test_case = test_case self . ignore_patterns = ignore_patterns or get_config ()[ \"IGNORE_SQL_PATTERNS\" ] self . num = num self . seconds = seconds","title":"__init__()"},{"location":"reference/utils/","text":"colorize ( value , is_warning ) \u00a4 Utility to set a color for the output string when it exceeds the threshold. Parameters: Name Type Description Default value str String to be output. required is_warning bool Whether it exceeds the threshold. required Returns: Type Description str colorized string output Source code in django_query_capture/utils.py def colorize ( value : str , is_warning : bool ) -> str : \"\"\" Utility to set a color for the output string when it exceeds the threshold. Args: value: String to be output. is_warning: Whether it exceeds the threshold. Returns: colorized string output \"\"\" if is_warning : return termcolors . make_style ( fg = get_config ()[ \"PRINT_THRESHOLDS\" ][ \"COLOR\" ])( # type: ignore value ) return value get_stack_prefix ( captured_query ) \u00a4 Utilities that help you output call stacks consistently in CapturedQuery . Parameters: Name Type Description Default captured_query CapturedQuery CapturedQuery required Source code in django_query_capture/utils.py def get_stack_prefix ( captured_query : CapturedQuery ) -> str : \"\"\" Utilities that help you output call stacks consistently in [CapturedQuery][capture.CapturedQuery]. Args: captured_query: [CapturedQuery][capture.CapturedQuery] \"\"\" return f '[ { captured_query [ \"function_name\" ] } , { captured_query [ \"file_name\" ] } : { captured_query [ \"line_no\" ] } ]' truncate_string ( value , length ) \u00a4 Parameters: Name Type Description Default value str String to be output. required length int Number of strings to output. required Returns: Type Description str truncated string Source code in django_query_capture/utils.py def truncate_string ( value : str , length : int ) -> str : \"\"\" Args: value: String to be output. length: Number of strings to output. Returns: truncated string \"\"\" return ( value [: length ] + \"..\" ) if len ( value ) > length else value","title":"utils.py"},{"location":"reference/utils/#utils.colorize","text":"Utility to set a color for the output string when it exceeds the threshold. Parameters: Name Type Description Default value str String to be output. required is_warning bool Whether it exceeds the threshold. required Returns: Type Description str colorized string output Source code in django_query_capture/utils.py def colorize ( value : str , is_warning : bool ) -> str : \"\"\" Utility to set a color for the output string when it exceeds the threshold. Args: value: String to be output. is_warning: Whether it exceeds the threshold. Returns: colorized string output \"\"\" if is_warning : return termcolors . make_style ( fg = get_config ()[ \"PRINT_THRESHOLDS\" ][ \"COLOR\" ])( # type: ignore value ) return value","title":"colorize()"},{"location":"reference/utils/#utils.get_stack_prefix","text":"Utilities that help you output call stacks consistently in CapturedQuery . Parameters: Name Type Description Default captured_query CapturedQuery CapturedQuery required Source code in django_query_capture/utils.py def get_stack_prefix ( captured_query : CapturedQuery ) -> str : \"\"\" Utilities that help you output call stacks consistently in [CapturedQuery][capture.CapturedQuery]. Args: captured_query: [CapturedQuery][capture.CapturedQuery] \"\"\" return f '[ { captured_query [ \"function_name\" ] } , { captured_query [ \"file_name\" ] } : { captured_query [ \"line_no\" ] } ]'","title":"get_stack_prefix()"},{"location":"reference/utils/#utils.truncate_string","text":"Parameters: Name Type Description Default value str String to be output. required length int Number of strings to output. required Returns: Type Description str truncated string Source code in django_query_capture/utils.py def truncate_string ( value : str , length : int ) -> str : \"\"\" Args: value: String to be output. length: Number of strings to output. Returns: truncated string \"\"\" return ( value [: length ] + \"..\" ) if len ( value ) > length else value","title":"truncate_string()"},{"location":"reference/presenter/base/","text":"BasePresenter \u00a4 This is the parent value that can be set to PRESENTER setting. You can use the classified_query attribute to determine the output. The output can be completed by overriding the print method using the classified_query attributes. Source code in presenter/base.py class BasePresenter : \"\"\" This is the parent value that can be set to [PRESENTER](../../home/settings.md) setting.<br> You can use the [classified_query][classify.ClassifiedQuery] attribute to determine the output.<br> The output can be completed by overriding the print method using the [classified_query][classify.ClassifiedQuery] attributes. \"\"\" def __init__ ( self , classified_query : ClassifiedQuery ): self . classified_query = classified_query def print ( self ) -> None : raise NotImplementedError","title":"base.py"},{"location":"reference/presenter/base/#presenter.base.BasePresenter","text":"This is the parent value that can be set to PRESENTER setting. You can use the classified_query attribute to determine the output. The output can be completed by overriding the print method using the classified_query attributes. Source code in presenter/base.py class BasePresenter : \"\"\" This is the parent value that can be set to [PRESENTER](../../home/settings.md) setting.<br> You can use the [classified_query][classify.ClassifiedQuery] attribute to determine the output.<br> The output can be completed by overriding the print method using the [classified_query][classify.ClassifiedQuery] attributes. \"\"\" def __init__ ( self , classified_query : ClassifiedQuery ): self . classified_query = classified_query def print ( self ) -> None : raise NotImplementedError","title":"BasePresenter"},{"location":"reference/presenter/only_slow_query/","text":"OnlySlowQueryPresenter ( BasePresenter ) \u00a4 Only queries exceeding the SLOW_MIN_SECOND threshold are output. Source code in presenter/only_slow_query.py class OnlySlowQueryPresenter ( BasePresenter ): \"\"\" Only queries exceeding the [SLOW_MIN_SECOND](../../home/settings.md) threshold are output. \"\"\" def print ( self ) -> None : for captured_query in self . classified_query [ \"slow_captured_queries\" ]: print ( colorize ( f ' { get_stack_prefix ( captured_query ) } Slow { captured_query [ \"duration\" ] : .2f } seconds' , is_warning = True , ) )","title":"only_slow_query.py"},{"location":"reference/presenter/only_slow_query/#presenter.only_slow_query.OnlySlowQueryPresenter","text":"Only queries exceeding the SLOW_MIN_SECOND threshold are output. Source code in presenter/only_slow_query.py class OnlySlowQueryPresenter ( BasePresenter ): \"\"\" Only queries exceeding the [SLOW_MIN_SECOND](../../home/settings.md) threshold are output. \"\"\" def print ( self ) -> None : for captured_query in self . classified_query [ \"slow_captured_queries\" ]: print ( colorize ( f ' { get_stack_prefix ( captured_query ) } Slow { captured_query [ \"duration\" ] : .2f } seconds' , is_warning = True , ) )","title":"OnlySlowQueryPresenter"},{"location":"reference/presenter/pretty/","text":"PrettyPresenter ( BasePresenter ) \u00a4 Outputs all elements of ClassifiedQuery with formatting. termscolor: https://github.com/django/django/blob/main/django/utils/termcolors.py tabulate: https://github.com/astanin/python-tabulate#table-format pygments: https://pygments.org/styles/ Source code in presenter/pretty.py class PrettyPresenter ( BasePresenter ): \"\"\" Outputs all elements of [ClassifiedQuery][classify.ClassifiedQuery] with formatting.<br> termscolor: [https://github.com/django/django/blob/main/django/utils/termcolors.py](https://github.com/django/django/blob/main/django/utils/termcolors.py)<br> tabulate: [https://github.com/astanin/python-tabulate#table-format](https://github.com/astanin/python-tabulate#table-format) <br> pygments: [https://pygments.org/styles/](https://pygments.org/styles/) \"\"\" @staticmethod def print_sql ( sql : str ) -> None : print ( highlight ( sqlparse . format ( sql , reindent = True , keyword_case = \"upper\" ), SqlLexer (), TerminalTrueColorFormatter ( style = get_config ()[ \"PRETTY\" ][ \"SQL_COLOR_FORMAT\" ] ), ) ) def get_stats_table ( self , is_warning : bool = False ) -> str : return colorize ( tabulate ( [ [ self . classified_query [ \"read\" ], self . classified_query [ \"writes\" ], self . classified_query [ \"total\" ], f \" { self . classified_query [ 'total_duration' ] : .2f } \" , self . classified_query [ \"most_common_duplicate\" ][ 1 ] if self . classified_query [ \"most_common_duplicate\" ] else 0 , self . classified_query [ \"most_common_similar\" ][ 1 ] if self . classified_query [ \"most_common_similar\" ] else 0 , ] ], [ \"read\" , \"writes\" , \"total\" , \"total_duration\" , \"most_common_duplicates\" , \"most_common_similar\" , ], tablefmt = get_config ()[ \"PRETTY\" ][ \"TABLE_FORMAT\" ], ), is_warning , ) def print ( self ) -> None : is_warning = self . classified_query [ \"has_over_threshold\" ] print ( \" \\n \" + self . get_stats_table ( is_warning )) for captured_query in self . classified_query [ \"slow_captured_queries\" ]: print ( f ' { get_stack_prefix ( captured_query ) } Slow { captured_query [ \"duration\" ] : .2f } seconds' ) self . print_sql ( captured_query [ \"sql\" ]) for captured_query , count in self . classified_query [ \"duplicates_counter_over_threshold\" ] . items (): print ( f \" { get_stack_prefix ( captured_query ) } Repeated { count } times\" ) self . print_sql ( captured_query [ \"sql\" ]) for captured_query , count in self . classified_query [ \"similar_counter_over_threshold\" ] . items (): print ( f \" { get_stack_prefix ( captured_query ) } Similar { count } times\" ) self . print_sql ( captured_query [ \"raw_sql\" ])","title":"pretty.py"},{"location":"reference/presenter/pretty/#presenter.pretty.PrettyPresenter","text":"Outputs all elements of ClassifiedQuery with formatting. termscolor: https://github.com/django/django/blob/main/django/utils/termcolors.py tabulate: https://github.com/astanin/python-tabulate#table-format pygments: https://pygments.org/styles/ Source code in presenter/pretty.py class PrettyPresenter ( BasePresenter ): \"\"\" Outputs all elements of [ClassifiedQuery][classify.ClassifiedQuery] with formatting.<br> termscolor: [https://github.com/django/django/blob/main/django/utils/termcolors.py](https://github.com/django/django/blob/main/django/utils/termcolors.py)<br> tabulate: [https://github.com/astanin/python-tabulate#table-format](https://github.com/astanin/python-tabulate#table-format) <br> pygments: [https://pygments.org/styles/](https://pygments.org/styles/) \"\"\" @staticmethod def print_sql ( sql : str ) -> None : print ( highlight ( sqlparse . format ( sql , reindent = True , keyword_case = \"upper\" ), SqlLexer (), TerminalTrueColorFormatter ( style = get_config ()[ \"PRETTY\" ][ \"SQL_COLOR_FORMAT\" ] ), ) ) def get_stats_table ( self , is_warning : bool = False ) -> str : return colorize ( tabulate ( [ [ self . classified_query [ \"read\" ], self . classified_query [ \"writes\" ], self . classified_query [ \"total\" ], f \" { self . classified_query [ 'total_duration' ] : .2f } \" , self . classified_query [ \"most_common_duplicate\" ][ 1 ] if self . classified_query [ \"most_common_duplicate\" ] else 0 , self . classified_query [ \"most_common_similar\" ][ 1 ] if self . classified_query [ \"most_common_similar\" ] else 0 , ] ], [ \"read\" , \"writes\" , \"total\" , \"total_duration\" , \"most_common_duplicates\" , \"most_common_similar\" , ], tablefmt = get_config ()[ \"PRETTY\" ][ \"TABLE_FORMAT\" ], ), is_warning , ) def print ( self ) -> None : is_warning = self . classified_query [ \"has_over_threshold\" ] print ( \" \\n \" + self . get_stats_table ( is_warning )) for captured_query in self . classified_query [ \"slow_captured_queries\" ]: print ( f ' { get_stack_prefix ( captured_query ) } Slow { captured_query [ \"duration\" ] : .2f } seconds' ) self . print_sql ( captured_query [ \"sql\" ]) for captured_query , count in self . classified_query [ \"duplicates_counter_over_threshold\" ] . items (): print ( f \" { get_stack_prefix ( captured_query ) } Repeated { count } times\" ) self . print_sql ( captured_query [ \"sql\" ]) for captured_query , count in self . classified_query [ \"similar_counter_over_threshold\" ] . items (): print ( f \" { get_stack_prefix ( captured_query ) } Similar { count } times\" ) self . print_sql ( captured_query [ \"raw_sql\" ])","title":"PrettyPresenter"},{"location":"reference/presenter/raw_line/","text":"RawLinePresenter ( BasePresenter ) \u00a4 Outputs all elements of ClassifiedQuery without formatting. Source code in presenter/raw_line.py class RawLinePresenter ( BasePresenter ): \"\"\" Outputs all elements of [ClassifiedQuery][classify.ClassifiedQuery] without formatting. \"\"\" def print ( self ) -> None : print ( f \"read: { self . classified_query [ 'read' ] } \\n \" , f \"writes: { self . classified_query [ 'writes' ] } \\n \" , f \"total: { self . classified_query [ 'total' ] } \\n \" , f \"total_duration: { self . classified_query [ 'total_duration' ] : .2f } \\n \" , f \"most_common_duplicates: { self . classified_query [ 'most_common_duplicate' ][ 1 ] if self . classified_query [ 'most_common_duplicate' ] else 0 } \\n \" , f \"most_common_similar: { self . classified_query [ 'most_common_similar' ][ 1 ] if self . classified_query [ 'most_common_similar' ] else 0 } \\n \" , ) for captured_query in self . classified_query [ \"slow_captured_queries\" ]: print ( f ' { get_stack_prefix ( captured_query ) } Slow { captured_query [ \"duration\" ] : .2f } seconds' ) print ( sqlparse . format ( captured_query [ \"sql\" ], reindent = True , keyword_case = \"upper\" ) ) for captured_query , count in self . classified_query [ \"duplicates_counter_over_threshold\" ] . items (): print ( f \" { get_stack_prefix ( captured_query ) } Repeated { count } times\" ) print ( sqlparse . format ( captured_query [ \"sql\" ], reindent = True , keyword_case = \"upper\" ) ) for captured_query , count in self . classified_query [ \"similar_counter_over_threshold\" ] . items (): print ( f \" { get_stack_prefix ( captured_query ) } Similar { count } times\" ) print ( sqlparse . format ( captured_query [ \"sql\" ], reindent = True , keyword_case = \"upper\" ) )","title":"raw_line.py"},{"location":"reference/presenter/raw_line/#presenter.raw_line.RawLinePresenter","text":"Outputs all elements of ClassifiedQuery without formatting. Source code in presenter/raw_line.py class RawLinePresenter ( BasePresenter ): \"\"\" Outputs all elements of [ClassifiedQuery][classify.ClassifiedQuery] without formatting. \"\"\" def print ( self ) -> None : print ( f \"read: { self . classified_query [ 'read' ] } \\n \" , f \"writes: { self . classified_query [ 'writes' ] } \\n \" , f \"total: { self . classified_query [ 'total' ] } \\n \" , f \"total_duration: { self . classified_query [ 'total_duration' ] : .2f } \\n \" , f \"most_common_duplicates: { self . classified_query [ 'most_common_duplicate' ][ 1 ] if self . classified_query [ 'most_common_duplicate' ] else 0 } \\n \" , f \"most_common_similar: { self . classified_query [ 'most_common_similar' ][ 1 ] if self . classified_query [ 'most_common_similar' ] else 0 } \\n \" , ) for captured_query in self . classified_query [ \"slow_captured_queries\" ]: print ( f ' { get_stack_prefix ( captured_query ) } Slow { captured_query [ \"duration\" ] : .2f } seconds' ) print ( sqlparse . format ( captured_query [ \"sql\" ], reindent = True , keyword_case = \"upper\" ) ) for captured_query , count in self . classified_query [ \"duplicates_counter_over_threshold\" ] . items (): print ( f \" { get_stack_prefix ( captured_query ) } Repeated { count } times\" ) print ( sqlparse . format ( captured_query [ \"sql\" ], reindent = True , keyword_case = \"upper\" ) ) for captured_query , count in self . classified_query [ \"similar_counter_over_threshold\" ] . items (): print ( f \" { get_stack_prefix ( captured_query ) } Similar { count } times\" ) print ( sqlparse . format ( captured_query [ \"sql\" ], reindent = True , keyword_case = \"upper\" ) )","title":"RawLinePresenter"},{"location":"reference/presenter/simple/","text":"SimplePresenter ( BasePresenter ) \u00a4 only print total queries, duration. Source code in presenter/simple.py class SimplePresenter ( BasePresenter ): \"\"\" only print total queries, duration. \"\"\" def print ( self ) -> None : print ( f 'total: { self . classified_query [ \"total\" ] } queries in { self . classified_query [ \"total_duration\" ] : .2f } seconds' )","title":"simple.py"},{"location":"reference/presenter/simple/#presenter.simple.SimplePresenter","text":"only print total queries, duration. Source code in presenter/simple.py class SimplePresenter ( BasePresenter ): \"\"\" only print total queries, duration. \"\"\" def print ( self ) -> None : print ( f 'total: { self . classified_query [ \"total\" ] } queries in { self . classified_query [ \"total_duration\" ] : .2f } seconds' )","title":"SimplePresenter"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}